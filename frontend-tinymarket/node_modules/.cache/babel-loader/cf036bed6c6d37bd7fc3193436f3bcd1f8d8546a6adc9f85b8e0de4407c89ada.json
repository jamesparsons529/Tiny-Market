{"ast":null,"code":"import { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\nexport function cvToString(val, encoding = 'hex') {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = bytesToAscii(val.buffer);\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${cvToString(val.data[key], encoding)})`).join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\nexport function cvToValue(val, strictJsonCompat = false) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      }\n      return val.value;\n    case ClarityType.Buffer:\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\nexport function cvToJSON(val) {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: false\n      };\n    case ClarityType.ResponseOk:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: true\n      };\n    default:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true)\n      };\n  }\n}\nexport function getCVTypeString(val) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${getCVTypeString(val.data[key])})`).join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\n  }\n}","map":{"version":3,"names":["principalToString","ClarityType","asciiToBytes","bytesToAscii","bytesToHex","utf8ToBytes","cvToString","val","encoding","type","BoolTrue","BoolFalse","Int","value","toString","UInt","Buffer","str","buffer","test","JSON","stringify","OptionalNone","OptionalSome","ResponseErr","ResponseOk","PrincipalStandard","PrincipalContract","List","list","map","v","join","Tuple","Object","keys","data","key","StringASCII","StringUTF8","cvToValue","strictJsonCompat","cvToJSON","result","forEach","getCVTypeString","success","length"],"sources":["C:\\Users\\user\\Documents\\Tiny-Market\\frontend-tinymarket\\node_modules\\@stacks\\transactions\\src\\clarity\\clarityValue.ts"],"sourcesContent":["import {\r\n  BooleanCV,\r\n  BufferCV,\r\n  IntCV,\r\n  UIntCV,\r\n  StandardPrincipalCV,\r\n  ContractPrincipalCV,\r\n  ResponseErrorCV,\r\n  ResponseOkCV,\r\n  ListCV,\r\n  TupleCV,\r\n  StringAsciiCV,\r\n  StringUtf8CV,\r\n  NoneCV,\r\n  SomeCV,\r\n} from '.';\r\n\r\nimport { principalToString } from './types/principalCV';\r\nimport { ClarityType } from './constants';\r\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\r\n\r\nexport type ClarityValue =\r\n  | BooleanCV\r\n  | BufferCV\r\n  | IntCV\r\n  | UIntCV\r\n  | StandardPrincipalCV\r\n  | ContractPrincipalCV\r\n  | ResponseErrorCV\r\n  | ResponseOkCV\r\n  | NoneCV\r\n  | SomeCV\r\n  | ListCV\r\n  | TupleCV\r\n  | StringAsciiCV\r\n  | StringUtf8CV;\r\n\r\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\r\n  switch (val.type) {\r\n    case ClarityType.BoolTrue:\r\n      return 'true';\r\n    case ClarityType.BoolFalse:\r\n      return 'false';\r\n    case ClarityType.Int:\r\n      return val.value.toString();\r\n    case ClarityType.UInt:\r\n      return `u${val.value.toString()}`;\r\n    case ClarityType.Buffer:\r\n      if (encoding === 'tryAscii') {\r\n        const str = bytesToAscii(val.buffer);\r\n        if (/[ -~]/.test(str)) {\r\n          return JSON.stringify(str);\r\n        }\r\n      }\r\n      return `0x${bytesToHex(val.buffer)}`;\r\n    case ClarityType.OptionalNone:\r\n      return 'none';\r\n    case ClarityType.OptionalSome:\r\n      return `(some ${cvToString(val.value, encoding)})`;\r\n    case ClarityType.ResponseErr:\r\n      return `(err ${cvToString(val.value, encoding)})`;\r\n    case ClarityType.ResponseOk:\r\n      return `(ok ${cvToString(val.value, encoding)})`;\r\n    case ClarityType.PrincipalStandard:\r\n    case ClarityType.PrincipalContract:\r\n      return principalToString(val);\r\n    case ClarityType.List:\r\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\r\n    case ClarityType.Tuple:\r\n      return `(tuple ${Object.keys(val.data)\r\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\r\n        .join(' ')})`;\r\n    case ClarityType.StringASCII:\r\n      return `\"${val.data}\"`;\r\n    case ClarityType.StringUTF8:\r\n      return `u\"${val.data}\"`;\r\n  }\r\n}\r\n\r\n/**\r\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\r\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\r\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\r\n */\r\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\r\n  switch (val.type) {\r\n    case ClarityType.BoolTrue:\r\n      return true;\r\n    case ClarityType.BoolFalse:\r\n      return false;\r\n    case ClarityType.Int:\r\n    case ClarityType.UInt:\r\n      if (strictJsonCompat) {\r\n        return val.value.toString();\r\n      }\r\n      return val.value;\r\n    case ClarityType.Buffer:\r\n      return `0x${bytesToHex(val.buffer)}`;\r\n    case ClarityType.OptionalNone:\r\n      return null;\r\n    case ClarityType.OptionalSome:\r\n      return cvToJSON(val.value);\r\n    case ClarityType.ResponseErr:\r\n      return cvToJSON(val.value);\r\n    case ClarityType.ResponseOk:\r\n      return cvToJSON(val.value);\r\n    case ClarityType.PrincipalStandard:\r\n    case ClarityType.PrincipalContract:\r\n      return principalToString(val);\r\n    case ClarityType.List:\r\n      return val.list.map(v => cvToJSON(v));\r\n    case ClarityType.Tuple:\r\n      const result: { [key: string]: any } = {};\r\n      Object.keys(val.data).forEach(key => {\r\n        result[key] = cvToJSON(val.data[key]);\r\n      });\r\n      return result;\r\n    case ClarityType.StringASCII:\r\n      return val.data;\r\n    case ClarityType.StringUTF8:\r\n      return val.data;\r\n  }\r\n}\r\n\r\nexport function cvToJSON(val: ClarityValue): any {\r\n  switch (val.type) {\r\n    case ClarityType.ResponseErr:\r\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\r\n    case ClarityType.ResponseOk:\r\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\r\n    default:\r\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\r\n  }\r\n}\r\n\r\nexport function getCVTypeString(val: ClarityValue): string {\r\n  switch (val.type) {\r\n    case ClarityType.BoolTrue:\r\n    case ClarityType.BoolFalse:\r\n      return 'bool';\r\n    case ClarityType.Int:\r\n      return 'int';\r\n    case ClarityType.UInt:\r\n      return 'uint';\r\n    case ClarityType.Buffer:\r\n      return `(buff ${val.buffer.length})`;\r\n    case ClarityType.OptionalNone:\r\n      return '(optional none)';\r\n    case ClarityType.OptionalSome:\r\n      return `(optional ${getCVTypeString(val.value)})`;\r\n    case ClarityType.ResponseErr:\r\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\r\n    case ClarityType.ResponseOk:\r\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\r\n    case ClarityType.PrincipalStandard:\r\n    case ClarityType.PrincipalContract:\r\n      return 'principal';\r\n    case ClarityType.List:\r\n      return `(list ${val.list.length} ${\r\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\r\n      })`;\r\n    case ClarityType.Tuple:\r\n      return `(tuple ${Object.keys(val.data)\r\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\r\n        .join(' ')})`;\r\n    case ClarityType.StringASCII:\r\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\r\n    case ClarityType.StringUTF8:\r\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\r\n  }\r\n}\r\n"],"mappings":"AAiBA,SAASA,iBAAiB,QAAQ,qBAAqB;AACvD,SAASC,WAAW,QAAQ,aAAa;AACzC,SAASC,YAAY,EAAEC,YAAY,EAAEC,UAAU,EAAEC,WAAW,QAAQ,gBAAgB;AAkBpF,OAAM,SAAUC,UAAUA,CAACC,GAAiB,EAAEC,QAAA,GAA+B,KAAK;EAChF,QAAQD,GAAG,CAACE,IAAI;IACd,KAAKR,WAAW,CAACS,QAAQ;MACvB,OAAO,MAAM;IACf,KAAKT,WAAW,CAACU,SAAS;MACxB,OAAO,OAAO;IAChB,KAAKV,WAAW,CAACW,GAAG;MAClB,OAAOL,GAAG,CAACM,KAAK,CAACC,QAAQ,EAAE;IAC7B,KAAKb,WAAW,CAACc,IAAI;MACnB,OAAO,IAAIR,GAAG,CAACM,KAAK,CAACC,QAAQ,EAAE,EAAE;IACnC,KAAKb,WAAW,CAACe,MAAM;MACrB,IAAIR,QAAQ,KAAK,UAAU,EAAE;QAC3B,MAAMS,GAAG,GAAGd,YAAY,CAACI,GAAG,CAACW,MAAM,CAAC;QACpC,IAAI,OAAO,CAACC,IAAI,CAACF,GAAG,CAAC,EAAE;UACrB,OAAOG,IAAI,CAACC,SAAS,CAACJ,GAAG,CAAC;;;MAG9B,OAAO,KAAKb,UAAU,CAACG,GAAG,CAACW,MAAM,CAAC,EAAE;IACtC,KAAKjB,WAAW,CAACqB,YAAY;MAC3B,OAAO,MAAM;IACf,KAAKrB,WAAW,CAACsB,YAAY;MAC3B,OAAO,SAASjB,UAAU,CAACC,GAAG,CAACM,KAAK,EAAEL,QAAQ,CAAC,GAAG;IACpD,KAAKP,WAAW,CAACuB,WAAW;MAC1B,OAAO,QAAQlB,UAAU,CAACC,GAAG,CAACM,KAAK,EAAEL,QAAQ,CAAC,GAAG;IACnD,KAAKP,WAAW,CAACwB,UAAU;MACzB,OAAO,OAAOnB,UAAU,CAACC,GAAG,CAACM,KAAK,EAAEL,QAAQ,CAAC,GAAG;IAClD,KAAKP,WAAW,CAACyB,iBAAiB;IAClC,KAAKzB,WAAW,CAAC0B,iBAAiB;MAChC,OAAO3B,iBAAiB,CAACO,GAAG,CAAC;IAC/B,KAAKN,WAAW,CAAC2B,IAAI;MACnB,OAAO,SAASrB,GAAG,CAACsB,IAAI,CAACC,GAAG,CAACC,CAAC,IAAIzB,UAAU,CAACyB,CAAC,EAAEvB,QAAQ,CAAC,CAAC,CAACwB,IAAI,CAAC,GAAG,CAAC,GAAG;IACzE,KAAK/B,WAAW,CAACgC,KAAK;MACpB,OAAO,UAAUC,MAAM,CAACC,IAAI,CAAC5B,GAAG,CAAC6B,IAAI,CAAC,CACnCN,GAAG,CAACO,GAAG,IAAI,IAAIA,GAAG,IAAI/B,UAAU,CAACC,GAAG,CAAC6B,IAAI,CAACC,GAAG,CAAC,EAAE7B,QAAQ,CAAC,GAAG,CAAC,CAC7DwB,IAAI,CAAC,GAAG,CAAC,GAAG;IACjB,KAAK/B,WAAW,CAACqC,WAAW;MAC1B,OAAO,IAAI/B,GAAG,CAAC6B,IAAI,GAAG;IACxB,KAAKnC,WAAW,CAACsC,UAAU;MACzB,OAAO,KAAKhC,GAAG,CAAC6B,IAAI,GAAG;;AAE7B;AAOA,OAAM,SAAUI,SAASA,CAACjC,GAAiB,EAAEkC,gBAAA,GAA4B,KAAK;EAC5E,QAAQlC,GAAG,CAACE,IAAI;IACd,KAAKR,WAAW,CAACS,QAAQ;MACvB,OAAO,IAAI;IACb,KAAKT,WAAW,CAACU,SAAS;MACxB,OAAO,KAAK;IACd,KAAKV,WAAW,CAACW,GAAG;IACpB,KAAKX,WAAW,CAACc,IAAI;MACnB,IAAI0B,gBAAgB,EAAE;QACpB,OAAOlC,GAAG,CAACM,KAAK,CAACC,QAAQ,EAAE;;MAE7B,OAAOP,GAAG,CAACM,KAAK;IAClB,KAAKZ,WAAW,CAACe,MAAM;MACrB,OAAO,KAAKZ,UAAU,CAACG,GAAG,CAACW,MAAM,CAAC,EAAE;IACtC,KAAKjB,WAAW,CAACqB,YAAY;MAC3B,OAAO,IAAI;IACb,KAAKrB,WAAW,CAACsB,YAAY;MAC3B,OAAOmB,QAAQ,CAACnC,GAAG,CAACM,KAAK,CAAC;IAC5B,KAAKZ,WAAW,CAACuB,WAAW;MAC1B,OAAOkB,QAAQ,CAACnC,GAAG,CAACM,KAAK,CAAC;IAC5B,KAAKZ,WAAW,CAACwB,UAAU;MACzB,OAAOiB,QAAQ,CAACnC,GAAG,CAACM,KAAK,CAAC;IAC5B,KAAKZ,WAAW,CAACyB,iBAAiB;IAClC,KAAKzB,WAAW,CAAC0B,iBAAiB;MAChC,OAAO3B,iBAAiB,CAACO,GAAG,CAAC;IAC/B,KAAKN,WAAW,CAAC2B,IAAI;MACnB,OAAOrB,GAAG,CAACsB,IAAI,CAACC,GAAG,CAACC,CAAC,IAAIW,QAAQ,CAACX,CAAC,CAAC,CAAC;IACvC,KAAK9B,WAAW,CAACgC,KAAK;MACpB,MAAMU,MAAM,GAA2B,EAAE;MACzCT,MAAM,CAACC,IAAI,CAAC5B,GAAG,CAAC6B,IAAI,CAAC,CAACQ,OAAO,CAACP,GAAG,IAAG;QAClCM,MAAM,CAACN,GAAG,CAAC,GAAGK,QAAQ,CAACnC,GAAG,CAAC6B,IAAI,CAACC,GAAG,CAAC,CAAC;MACvC,CAAC,CAAC;MACF,OAAOM,MAAM;IACf,KAAK1C,WAAW,CAACqC,WAAW;MAC1B,OAAO/B,GAAG,CAAC6B,IAAI;IACjB,KAAKnC,WAAW,CAACsC,UAAU;MACzB,OAAOhC,GAAG,CAAC6B,IAAI;;AAErB;AAEA,OAAM,SAAUM,QAAQA,CAACnC,GAAiB;EACxC,QAAQA,GAAG,CAACE,IAAI;IACd,KAAKR,WAAW,CAACuB,WAAW;MAC1B,OAAO;QAAEf,IAAI,EAAEoC,eAAe,CAACtC,GAAG,CAAC;QAAEM,KAAK,EAAE2B,SAAS,CAACjC,GAAG,EAAE,IAAI,CAAC;QAAEuC,OAAO,EAAE;MAAK,CAAE;IACpF,KAAK7C,WAAW,CAACwB,UAAU;MACzB,OAAO;QAAEhB,IAAI,EAAEoC,eAAe,CAACtC,GAAG,CAAC;QAAEM,KAAK,EAAE2B,SAAS,CAACjC,GAAG,EAAE,IAAI,CAAC;QAAEuC,OAAO,EAAE;MAAI,CAAE;IACnF;MACE,OAAO;QAAErC,IAAI,EAAEoC,eAAe,CAACtC,GAAG,CAAC;QAAEM,KAAK,EAAE2B,SAAS,CAACjC,GAAG,EAAE,IAAI;MAAC,CAAE;;AAExE;AAEA,OAAM,SAAUsC,eAAeA,CAACtC,GAAiB;EAC/C,QAAQA,GAAG,CAACE,IAAI;IACd,KAAKR,WAAW,CAACS,QAAQ;IACzB,KAAKT,WAAW,CAACU,SAAS;MACxB,OAAO,MAAM;IACf,KAAKV,WAAW,CAACW,GAAG;MAClB,OAAO,KAAK;IACd,KAAKX,WAAW,CAACc,IAAI;MACnB,OAAO,MAAM;IACf,KAAKd,WAAW,CAACe,MAAM;MACrB,OAAO,SAAST,GAAG,CAACW,MAAM,CAAC6B,MAAM,GAAG;IACtC,KAAK9C,WAAW,CAACqB,YAAY;MAC3B,OAAO,iBAAiB;IAC1B,KAAKrB,WAAW,CAACsB,YAAY;MAC3B,OAAO,aAAasB,eAAe,CAACtC,GAAG,CAACM,KAAK,CAAC,GAAG;IACnD,KAAKZ,WAAW,CAACuB,WAAW;MAC1B,OAAO,yBAAyBqB,eAAe,CAACtC,GAAG,CAACM,KAAK,CAAC,GAAG;IAC/D,KAAKZ,WAAW,CAACwB,UAAU;MACzB,OAAO,aAAaoB,eAAe,CAACtC,GAAG,CAACM,KAAK,CAAC,eAAe;IAC/D,KAAKZ,WAAW,CAACyB,iBAAiB;IAClC,KAAKzB,WAAW,CAAC0B,iBAAiB;MAChC,OAAO,WAAW;IACpB,KAAK1B,WAAW,CAAC2B,IAAI;MACnB,OAAO,SAASrB,GAAG,CAACsB,IAAI,CAACkB,MAAM,IAC7BxC,GAAG,CAACsB,IAAI,CAACkB,MAAM,GAAGF,eAAe,CAACtC,GAAG,CAACsB,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,aACnD,GAAG;IACL,KAAK5B,WAAW,CAACgC,KAAK;MACpB,OAAO,UAAUC,MAAM,CAACC,IAAI,CAAC5B,GAAG,CAAC6B,IAAI,CAAC,CACnCN,GAAG,CAACO,GAAG,IAAI,IAAIA,GAAG,IAAIQ,eAAe,CAACtC,GAAG,CAAC6B,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,CAAC,CACxDL,IAAI,CAAC,GAAG,CAAC,GAAG;IACjB,KAAK/B,WAAW,CAACqC,WAAW;MAC1B,OAAO,iBAAiBpC,YAAY,CAACK,GAAG,CAAC6B,IAAI,CAAC,CAACW,MAAM,GAAG;IAC1D,KAAK9C,WAAW,CAACsC,UAAU;MACzB,OAAO,gBAAgBlC,WAAW,CAACE,GAAG,CAAC6B,IAAI,CAAC,CAACW,MAAM,GAAG;;AAE5D"},"metadata":{},"sourceType":"module","externalDependencies":[]}