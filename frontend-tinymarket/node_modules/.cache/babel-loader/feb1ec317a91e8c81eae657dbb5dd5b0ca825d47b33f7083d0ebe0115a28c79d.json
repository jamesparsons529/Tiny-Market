{"ast":null,"code":"import { bytesToHex, hexToBytes, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet, createFetchFn } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth } from './authorization';\nimport { deserializeCV, serializeCV } from './clarity';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, ClarityVersion } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport { createStacksPrivateKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBytes, publicKeyToAddress, publicKeyToString } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport async function getNonce(address, network) {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText);\n  return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  return estimateTransferUnsafe(transaction, network);\n}\nexport async function estimateTransferUnsafe(transaction, network) {\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\nexport async function estimateTransaction(transactionPayload, estimatedLen, network) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? {\n        estimated_len: estimatedLen\n      } : {})\n    })\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n    if (body?.reason === 'NoEstimateAvailable') {\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\n    }\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`);\n  }\n  const data = await response.json();\n  return data.estimations;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = createFetchFn()) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n    },\n    body: attachment ? JSON.stringify({\n      tx: bytesToHex(rawTx),\n      attachment: bytesToHex(attachment)\n    }) : rawTx\n  };\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return await response.json();\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${e.message}`);\n    }\n  }\n  const text = await response.text();\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return {\n    txid\n  };\n}\nexport async function getAbi(address, contractName, network) {\n  const options = {\n    method: 'GET'\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  return JSON.parse(await response.text());\n}\nfunction deriveNetwork(transaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    memo: '',\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n  let authorization = null;\n  let spendingCondition = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const transaction = new StacksTransaction(network.version, authorization, payload, undefined, undefined, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport async function estimateContractDeploy(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract && transaction.payload.payloadType !== PayloadType.VersionedSmartContract) {\n    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractDeploy({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractDeploy(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport async function makeUnsignedContractDeploy(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createSmartContractPayload(options.contractName, options.codeBody, options.clarityVersion);\n  let authorization = null;\n  let spendingCondition = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n  if (options?.validateWithAbi) {\n    let abi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n    validateContractCall(payload, abi);\n  }\n  let spendingCondition = null;\n  let authorization = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function makeContractCall(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetId);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetId);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    senderAddress\n  } = options;\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n  const args = functionArgs.map(arg => cvToHex(arg));\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args\n  });\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function getContractMapEntry(getContractMapEntryOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const {\n    contractAddress,\n    contractName,\n    mapName,\n    mapKey,\n    network\n  } = Object.assign(defaultOptions, getContractMapEntryOptions);\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n  const fetchOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json'\n    },\n    body: JSON.stringify(serializedKeyHex)\n  };\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const responseBody = await response.text();\n  const responseJson = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(`Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`);\n  }\n  let deserializedCv;\n  try {\n    deserializedCv = deserializeCV(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\nexport async function sponsorTransaction(sponsorOptions) {\n  const defaultOptions = {\n    fee: 0,\n    sponsorNonce: 0,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    network: sponsorOptions.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet()\n  };\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1].fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n  options.transaction.setSponsor(sponsorSpendingCondition);\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n  signer.signSponsor(privKey);\n  return signer.transaction;\n}\nexport function estimateTransactionByteLength(transaction) {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition = transaction.auth.spendingCondition;\n    const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length;\n    const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) * (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    return transaction.serialize().byteLength;\n  }\n}\nexport async function estimateTransactionFeeWithFallback(transaction, network) {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["bytesToHex","hexToBytes","intToBigInt","StacksNetwork","StacksMainnet","StacksTestnet","createFetchFn","c32address","createMultiSigSpendingCondition","createSingleSigSpendingCondition","createSponsoredAuth","createStandardAuth","deserializeCV","serializeCV","AddressHashMode","AddressVersion","PayloadType","PostConditionMode","TransactionVersion","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","ClarityVersion","validateContractCall","NoEstimateAvailableError","createStacksPrivateKey","getPublicKey","pubKeyfromPrivKey","publicKeyFromBytes","publicKeyToAddress","publicKeyToString","createContractCallPayload","createSmartContractPayload","createTokenTransferPayload","serializePayload","createFungiblePostCondition","createNonFungiblePostCondition","createSTXPostCondition","createContractPrincipal","createStandardPrincipal","TransactionSigner","StacksTransaction","createLPList","cvToHex","omit","parseReadOnlyResponse","validateTxId","getNonce","address","network","derivedNetwork","fromNameOrNetwork","url","getAccountApiUrl","response","fetchFn","ok","msg","text","error","Error","status","statusText","responseText","result","JSON","parse","BigInt","nonce","estimateTransfer","transaction","payload","payloadType","TokenTransfer","estimateTransferUnsafe","requestHeaders","Accept","fetchOptions","method","headers","deriveNetwork","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","serialize","byteLength","feeRate","estimateTransaction","transactionPayload","estimatedLen","options","body","stringify","transaction_payload","estimated_len","getTransactionFeeEstimateApiUrl","json","catch","reason","reason_data","message","data","estimations","broadcastTransaction","attachment","rawTx","getBroadcastApiUrl","broadcastRawTransaction","tx","e","txid","replace","getAbi","contractName","getAbiApiUrl","version","Mainnet","Testnet","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","fee","memo","sponsored","Object","assign","recipient","amount","authorization","spendingCondition","SerializeP2PKH","publicKey","SerializeP2SH","numSignatures","publicKeys","undefined","anchorMode","chainId","estimateTransactionFeeWithFallback","setFee","addressVersion","MainnetSingleSig","TestnetSingleSig","senderAddress","auth","signer","txNonce","setNonce","makeSTXTokenTransfer","senderKey","privKey","signOrigin","pubKeys","key","signerKeys","pubKey","filter","pk","appendOrigin","estimateContractDeploy","SmartContract","VersionedSmartContract","makeContractDeploy","makeUnsignedContractDeploy","postConditionMode","Deny","clarityVersion","Clarity2","codeBody","postConditions","length","forEach","postCondition","push","lpPostConditions","estimateContractFunctionCall","ContractCall","makeUnsignedContractCall","contractAddress","functionName","functionArgs","validateWithAbi","abi","makeContractCall","makeStandardSTXPostCondition","conditionCode","makeContractSTXPostCondition","makeStandardFungiblePostCondition","assetInfo","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","assetId","makeContractNonFungiblePostCondition","callReadOnlyFunction","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","args","map","arg","sender","arguments","then","responseJson","getContractMapEntry","getContractMapEntryOptions","mapName","mapKey","getMapEntryUrl","serializedKeyBytes","serializedKeyHex","responseBody","deserializedCv","sponsorTransaction","sponsorOptions","sponsorNonce","sponsorAddressHashmode","sponsorPubKey","sponsorPrivateKey","txFee","estimateTransactionByteLength","sponsorSpendingCondition","setSponsor","createSponsorSigner","signSponsor","hashMode","multiSigHashModes","SerializeP2WSH","includes","multiSigSpendingCondition","existingSignatures","fields","field","contents","type","MessageSignature","totalSignatureLength","signaturesRequired"],"sources":["C:\\Users\\Elliott\\Tiny-Market\\frontend-tinymarket\\node_modules\\@stacks\\transactions\\src\\builders.ts"],"sourcesContent":["import { bytesToHex, hexToBytes, IntegerType, intToBigInt } from '@stacks/common';\r\nimport {\r\n  StacksNetwork,\r\n  StacksMainnet,\r\n  StacksNetworkName,\r\n  StacksTestnet,\r\n  FetchFn,\r\n  createFetchFn,\r\n} from '@stacks/network';\r\nimport { c32address } from 'c32check';\r\nimport {\r\n  Authorization,\r\n  createMultiSigSpendingCondition,\r\n  createSingleSigSpendingCondition,\r\n  createSponsoredAuth,\r\n  createStandardAuth,\r\n  SpendingCondition,\r\n  MultiSigSpendingCondition,\r\n} from './authorization';\r\nimport { ClarityValue, deserializeCV, NoneCV, PrincipalCV, serializeCV } from './clarity';\r\nimport {\r\n  AddressHashMode,\r\n  AddressVersion,\r\n  AnchorMode,\r\n  FungibleConditionCode,\r\n  NonFungibleConditionCode,\r\n  PayloadType,\r\n  PostConditionMode,\r\n  SingleSigHashMode,\r\n  TransactionVersion,\r\n  TxRejectedReason,\r\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\r\n  StacksMessageType,\r\n  ClarityVersion,\r\n  AnchorModeName,\r\n} from './constants';\r\nimport { ClarityAbi, validateContractCall } from './contract-abi';\r\nimport { NoEstimateAvailableError } from './errors';\r\nimport {\r\n  createStacksPrivateKey,\r\n  getPublicKey,\r\n  pubKeyfromPrivKey,\r\n  publicKeyFromBytes,\r\n  publicKeyToAddress,\r\n  publicKeyToString,\r\n} from './keys';\r\nimport {\r\n  createContractCallPayload,\r\n  createSmartContractPayload,\r\n  createTokenTransferPayload,\r\n  Payload,\r\n  serializePayload,\r\n} from './payload';\r\nimport {\r\n  createFungiblePostCondition,\r\n  createNonFungiblePostCondition,\r\n  createSTXPostCondition,\r\n} from './postcondition';\r\nimport {\r\n  AssetInfo,\r\n  createContractPrincipal,\r\n  createStandardPrincipal,\r\n  FungiblePostCondition,\r\n  NonFungiblePostCondition,\r\n  PostCondition,\r\n  STXPostCondition,\r\n} from './postcondition-types';\r\nimport { TransactionSigner } from './signer';\r\nimport { StacksTransaction } from './transaction';\r\nimport { createLPList } from './types';\r\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\r\n\r\n/**\r\n * Lookup the nonce for an address from a core node\r\n *\r\n * @param {string} address - the c32check address to look up\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\r\n *\r\n * @return a promise that resolves to an integer\r\n */\r\nexport async function getNonce(\r\n  address: string,\r\n  network?: StacksNetworkName | StacksNetwork\r\n): Promise<bigint> {\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\r\n  const url = derivedNetwork.getAccountApiUrl(address);\r\n\r\n  const response = await derivedNetwork.fetchFn(url);\r\n  if (!response.ok) {\r\n    let msg = '';\r\n    try {\r\n      msg = await response.text();\r\n    } catch (error) {}\r\n    throw new Error(\r\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n  const responseText = await response.text();\r\n  const result = JSON.parse(responseText) as { nonce: string };\r\n  return BigInt(result.nonce);\r\n}\r\n\r\n/**\r\n * @deprecated Use the new {@link estimateTransaction} function instead.\r\n *\r\n * Estimate the total transaction fee in microstacks for a token transfer\r\n *\r\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\r\n *\r\n * @return a promise that resolves to number of microstacks per byte\r\n */\r\nexport async function estimateTransfer(\r\n  transaction: StacksTransaction,\r\n  network?: StacksNetworkName | StacksNetwork\r\n): Promise<bigint> {\r\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\r\n    throw new Error(\r\n      `Transaction fee estimation only possible with ${\r\n        PayloadType[PayloadType.TokenTransfer]\r\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\r\n    );\r\n  }\r\n\r\n  return estimateTransferUnsafe(transaction, network);\r\n}\r\n\r\n/**\r\n * @deprecated Use the new {@link estimateTransaction} function instead.\r\n * @internal\r\n */\r\nexport async function estimateTransferUnsafe(\r\n  transaction: StacksTransaction,\r\n  network?: StacksNetworkName | StacksNetwork\r\n): Promise<bigint> {\r\n  const requestHeaders = {\r\n    Accept: 'application/text',\r\n  };\r\n\r\n  const fetchOptions = {\r\n    method: 'GET',\r\n    headers: requestHeaders,\r\n  };\r\n\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\r\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\r\n\r\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\r\n  if (!response.ok) {\r\n    let msg = '';\r\n    try {\r\n      msg = await response.text();\r\n    } catch (error) {}\r\n    throw new Error(\r\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n  const feeRateResult = await response.text();\r\n  const txBytes = BigInt(transaction.serialize().byteLength);\r\n  const feeRate = BigInt(feeRateResult);\r\n  return feeRate * txBytes;\r\n}\r\n\r\ninterface FeeEstimation {\r\n  fee: number;\r\n  fee_rate: number;\r\n}\r\ninterface FeeEstimateResponse {\r\n  cost_scalar_change_by_byte: bigint;\r\n  estimated_cost: {\r\n    read_count: bigint;\r\n    read_length: bigint;\r\n    runtime: bigint;\r\n    write_count: bigint;\r\n    write_length: bigint;\r\n  };\r\n  estimated_cost_scalar: bigint;\r\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\r\n}\r\n\r\n/**\r\n * Estimate the total transaction fee in microstacks for a Stacks transaction\r\n *\r\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\r\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\r\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\r\n * and signatures\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\r\n *\r\n * @return a promise that resolves to FeeEstimate\r\n */\r\nexport async function estimateTransaction(\r\n  transactionPayload: Payload,\r\n  estimatedLen?: number,\r\n  network?: StacksNetworkName | StacksNetwork\r\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\r\n  const options = {\r\n    method: 'POST',\r\n    headers: { 'Content-Type': 'application/json' },\r\n    body: JSON.stringify({\r\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\r\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\r\n    }),\r\n  };\r\n\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\r\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\r\n\r\n  const response = await derivedNetwork.fetchFn(url, options);\r\n\r\n  if (!response.ok) {\r\n    const body = await response.json().catch(() => ({}));\r\n\r\n    if (body?.reason === 'NoEstimateAvailable') {\r\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\r\n    }\r\n\r\n    throw new Error(\r\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`\r\n    );\r\n  }\r\n\r\n  const data: FeeEstimateResponse = await response.json();\r\n  return data.estimations;\r\n}\r\n\r\nexport type SerializationRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.Serialization;\r\n  reason_data: {\r\n    message: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type DeserializationRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.Deserialization;\r\n  reason_data: {\r\n    message: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type SignatureValidationRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.SignatureValidation;\r\n  reason_data: {\r\n    message: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type BadNonceRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.BadNonce;\r\n  reason_data: {\r\n    expected: number;\r\n    actual: number;\r\n    is_origin: boolean;\r\n    principal: boolean;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type FeeTooLowRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.FeeTooLow;\r\n  reason_data: {\r\n    expected: number;\r\n    actual: number;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type NotEnoughFundsRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.NotEnoughFunds;\r\n  reason_data: {\r\n    expected: string;\r\n    actual: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type NoSuchContractRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.NoSuchContract;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type NoSuchPublicFunctionRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.NoSuchPublicFunction;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type BadFunctionArgumentRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.BadFunctionArgument;\r\n  reason_data: {\r\n    message: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type ContractAlreadyExistsRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.ContractAlreadyExists;\r\n  reason_data: {\r\n    contract_identifier: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type PoisonMicroblocksDoNotConflictRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type PoisonMicroblockIsInvalidRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type BadAddressVersionByteRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.BadAddressVersionByte;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type NoCoinbaseViaMempoolRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type ServerFailureNoSuchChainTipRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\r\n  reason_data?: undefined;\r\n  txid: string;\r\n};\r\n\r\nexport type ServerFailureDatabaseRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.ServerFailureDatabase;\r\n  reason_data: {\r\n    message: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type ServerFailureOtherRejection = {\r\n  error: string;\r\n  reason: TxRejectedReason.ServerFailureOther;\r\n  reason_data: {\r\n    message: string;\r\n  };\r\n  txid: string;\r\n};\r\n\r\nexport type TxBroadcastResultOk = {\r\n  txid: string;\r\n  error?: undefined;\r\n  reason?: undefined;\r\n  reason_data?: undefined;\r\n};\r\n\r\nexport type TxBroadcastResultRejected =\r\n  | SerializationRejection\r\n  | DeserializationRejection\r\n  | SignatureValidationRejection\r\n  | BadNonceRejection\r\n  | FeeTooLowRejection\r\n  | NotEnoughFundsRejection\r\n  | NoSuchContractRejection\r\n  | NoSuchPublicFunctionRejection\r\n  | BadFunctionArgumentRejection\r\n  | ContractAlreadyExistsRejection\r\n  | PoisonMicroblocksDoNotConflictRejection\r\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\r\n  | PoisonMicroblockIsInvalidRejection\r\n  | BadAddressVersionByteRejection\r\n  | NoCoinbaseViaMempoolRejection\r\n  | ServerFailureNoSuchChainTipRejection\r\n  | ServerFailureDatabaseRejection\r\n  | ServerFailureOtherRejection;\r\n\r\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\r\n\r\n/**\r\n * Broadcast the signed transaction to a core node\r\n *\r\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\r\n *\r\n * @returns {Promise} that resolves to a response if the operation succeeds\r\n */\r\nexport async function broadcastTransaction(\r\n  transaction: StacksTransaction,\r\n  network?: StacksNetworkName | StacksNetwork,\r\n  attachment?: Uint8Array\r\n): Promise<TxBroadcastResult> {\r\n  const rawTx = transaction.serialize();\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\r\n  const url = derivedNetwork.getBroadcastApiUrl();\r\n\r\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\r\n}\r\n\r\n/**\r\n * Broadcast the signed transaction to a core node\r\n *\r\n * @param {Uint8Array} rawTx - the raw serialized transaction bytes to broadcast\r\n * @param {string} url - the broadcast endpoint URL\r\n *\r\n * @returns {Promise} that resolves to a response if the operation succeeds\r\n */\r\nexport async function broadcastRawTransaction(\r\n  rawTx: Uint8Array,\r\n  url: string,\r\n  attachment?: Uint8Array,\r\n  fetchFn: FetchFn = createFetchFn()\r\n): Promise<TxBroadcastResult> {\r\n  const options = {\r\n    method: 'POST',\r\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\r\n    body: attachment\r\n      ? JSON.stringify({\r\n          tx: bytesToHex(rawTx),\r\n          attachment: bytesToHex(attachment),\r\n        })\r\n      : rawTx,\r\n  };\r\n\r\n  const response = await fetchFn(url, options);\r\n  if (!response.ok) {\r\n    try {\r\n      return (await response.json()) as TxBroadcastResult;\r\n    } catch (e) {\r\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\r\n    }\r\n  }\r\n\r\n  const text = await response.text();\r\n  // Replace extra quotes around txid string\r\n  const txid = text.replace(/[\"]+/g, '');\r\n  if (!validateTxId(txid)) throw new Error(text);\r\n  return { txid } as TxBroadcastResult;\r\n}\r\n\r\n/**\r\n * Fetch a contract's ABI\r\n *\r\n * @param {string} address - the contracts address\r\n * @param {string} contractName - the contracts name\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\r\n *\r\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\r\n */\r\nexport async function getAbi(\r\n  address: string,\r\n  contractName: string,\r\n  network: StacksNetworkName | StacksNetwork\r\n): Promise<ClarityAbi> {\r\n  const options = {\r\n    method: 'GET',\r\n  };\r\n\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\r\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\r\n\r\n  const response = await derivedNetwork.fetchFn(url, options);\r\n  if (!response.ok) {\r\n    const msg = await response.text().catch(() => '');\r\n    throw new Error(\r\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n\r\n  return JSON.parse(await response.text()) as ClarityAbi;\r\n}\r\n\r\nfunction deriveNetwork(transaction: StacksTransaction) {\r\n  switch (transaction.version) {\r\n    case TransactionVersion.Mainnet:\r\n      return new StacksMainnet();\r\n    case TransactionVersion.Testnet:\r\n      return new StacksTestnet();\r\n  }\r\n}\r\n\r\nexport interface MultiSigOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n  signerKeys?: string[];\r\n}\r\n\r\n/**\r\n * STX token transfer transaction options\r\n */\r\nexport interface TokenTransferOptions {\r\n  /** the address of the recipient of the token transfer */\r\n  recipient: string | PrincipalCV;\r\n  /** the amount to be transfered in microstacks */\r\n  amount: IntegerType;\r\n  /** the transaction fee in microstacks */\r\n  fee?: IntegerType;\r\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\r\n  nonce?: IntegerType;\r\n  /** the network that the transaction will ultimately be broadcast to */\r\n  network?: StacksNetworkName | StacksNetwork;\r\n  /** the transaction anchorMode, which specifies whether it should be\r\n   * included in an anchor block or a microblock */\r\n  anchorMode: AnchorModeName | AnchorMode;\r\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\r\n  memo?: string;\r\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\r\n  sponsored?: boolean;\r\n}\r\n\r\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\r\n  publicKey: string;\r\n}\r\n\r\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\r\n  senderKey: string;\r\n}\r\n\r\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n}\r\n\r\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n  signerKeys: string[];\r\n}\r\n\r\n/**\r\n * Generates an unsigned Stacks token transfer transaction\r\n *\r\n * Returns a Stacks token transfer transaction.\r\n *\r\n * @param {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\r\n *\r\n * @return {Promise<StacksTransaction>}\r\n */\r\nexport async function makeUnsignedSTXTokenTransfer(\r\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\r\n): Promise<StacksTransaction> {\r\n  const defaultOptions = {\r\n    fee: BigInt(0),\r\n    nonce: BigInt(0),\r\n    network: new StacksMainnet(),\r\n    memo: '',\r\n    sponsored: false,\r\n  };\r\n\r\n  const options = Object.assign(defaultOptions, txOptions);\r\n\r\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\r\n\r\n  let authorization: Authorization | null = null;\r\n  let spendingCondition: SpendingCondition | null = null;\r\n\r\n  if ('publicKey' in options) {\r\n    // single-sig\r\n    spendingCondition = createSingleSigSpendingCondition(\r\n      AddressHashMode.SerializeP2PKH,\r\n      options.publicKey,\r\n      options.nonce,\r\n      options.fee\r\n    );\r\n  } else {\r\n    // multi-sig\r\n    spendingCondition = createMultiSigSpendingCondition(\r\n      AddressHashMode.SerializeP2SH,\r\n      options.numSignatures,\r\n      options.publicKeys,\r\n      options.nonce,\r\n      options.fee\r\n    );\r\n  }\r\n\r\n  if (options.sponsored) {\r\n    authorization = createSponsoredAuth(spendingCondition);\r\n  } else {\r\n    authorization = createStandardAuth(spendingCondition);\r\n  }\r\n\r\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\r\n\r\n  const transaction = new StacksTransaction(\r\n    network.version,\r\n    authorization,\r\n    payload,\r\n    undefined, // no post conditions on STX transfers (see SIP-005)\r\n    undefined, // no post conditions on STX transfers (see SIP-005)\r\n    options.anchorMode,\r\n    network.chainId\r\n  );\r\n\r\n  if (txOptions.fee === undefined || txOptions.fee === null) {\r\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\r\n    transaction.setFee(fee);\r\n  }\r\n\r\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\r\n    const addressVersion =\r\n      options.network.version === TransactionVersion.Mainnet\r\n        ? AddressVersion.MainnetSingleSig\r\n        : AddressVersion.TestnetSingleSig;\r\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\r\n    const txNonce = await getNonce(senderAddress, options.network);\r\n    transaction.setNonce(txNonce);\r\n  }\r\n\r\n  return transaction;\r\n}\r\n\r\n/**\r\n * Generates a signed Stacks token transfer transaction\r\n *\r\n * Returns a signed Stacks token transfer transaction.\r\n *\r\n * @param {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\r\n *\r\n * @return {StacksTransaction}\r\n */\r\nexport async function makeSTXTokenTransfer(\r\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\r\n): Promise<StacksTransaction> {\r\n  if ('senderKey' in txOptions) {\r\n    // txOptions is SignedTokenTransferOptions\r\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\r\n    const options = omit(txOptions, 'senderKey');\r\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\r\n\r\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\r\n    const signer = new TransactionSigner(transaction);\r\n    signer.signOrigin(privKey);\r\n\r\n    return transaction;\r\n  } else {\r\n    // txOptions is SignedMultiSigTokenTransferOptions\r\n    const options = omit(txOptions, 'signerKeys');\r\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\r\n\r\n    const signer = new TransactionSigner(transaction);\r\n    let pubKeys = txOptions.publicKeys;\r\n    for (const key of txOptions.signerKeys) {\r\n      const pubKey = pubKeyfromPrivKey(key);\r\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\r\n      signer.signOrigin(createStacksPrivateKey(key));\r\n    }\r\n\r\n    for (const key of pubKeys) {\r\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\r\n    }\r\n\r\n    return transaction;\r\n  }\r\n}\r\n\r\n/**\r\n * Contract deploy transaction options\r\n */\r\nexport interface BaseContractDeployOptions {\r\n  clarityVersion?: ClarityVersion;\r\n  contractName: string;\r\n  /** the Clarity code to be deployed */\r\n  codeBody: string;\r\n  /** transaction fee in microstacks */\r\n  fee?: IntegerType;\r\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\r\n  nonce?: IntegerType;\r\n  /** the network that the transaction will ultimately be broadcast to */\r\n  network?: StacksNetworkName | StacksNetwork;\r\n  /** the transaction anchorMode, which specifies whether it should be\r\n   * included in an anchor block or a microblock */\r\n  anchorMode: AnchorModeName | AnchorMode;\r\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\r\n   * transfered assets */\r\n  postConditionMode?: PostConditionMode;\r\n  /** a list of post conditions to add to the transaction */\r\n  postConditions?: PostCondition[];\r\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\r\n  sponsored?: boolean;\r\n}\r\n\r\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\r\n  /** a hex string of the public key of the transaction sender */\r\n  publicKey: string;\r\n}\r\n\r\nexport interface SignedContractDeployOptions extends BaseContractDeployOptions {\r\n  senderKey: string;\r\n}\r\n\r\n/** @deprecated Use {@link SignedContractDeployOptions} or {@link UnsignedContractDeployOptions} instead. */\r\nexport interface ContractDeployOptions extends SignedContractDeployOptions {}\r\n\r\nexport interface UnsignedMultiSigContractDeployOptions extends BaseContractDeployOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n}\r\n\r\nexport interface SignedMultiSigContractDeployOptions extends BaseContractDeployOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n  signerKeys: string[];\r\n}\r\n\r\n/**\r\n * @deprecated Use the new {@link estimateTransaction} function insterad.\r\n *\r\n * Estimate the total transaction fee in microstacks for a contract deploy\r\n *\r\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\r\n *\r\n * @return a promise that resolves to number of microstacks per byte\r\n */\r\nexport async function estimateContractDeploy(\r\n  transaction: StacksTransaction,\r\n  network?: StacksNetworkName | StacksNetwork\r\n): Promise<bigint> {\r\n  if (\r\n    transaction.payload.payloadType !== PayloadType.SmartContract &&\r\n    transaction.payload.payloadType !== PayloadType.VersionedSmartContract\r\n  ) {\r\n    throw new Error(\r\n      `Contract deploy fee estimation only possible with ${\r\n        PayloadType[PayloadType.SmartContract]\r\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\r\n    );\r\n  }\r\n\r\n  const requestHeaders = {\r\n    Accept: 'application/text',\r\n  };\r\n\r\n  const fetchOptions = {\r\n    method: 'GET',\r\n    headers: requestHeaders,\r\n  };\r\n\r\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\r\n  // blockchain core\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\r\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\r\n\r\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\r\n  if (!response.ok) {\r\n    const msg = await response.text().catch(() => '');\r\n    throw new Error(\r\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n  const feeRateResult = await response.text();\r\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\r\n  const feeRate = intToBigInt(feeRateResult, false);\r\n  return feeRate * txBytes;\r\n}\r\n\r\n/**\r\n * Generates a Clarity smart contract deploy transaction\r\n *\r\n * @param {SignedContractDeployOptions | SignedMultiSigContractDeployOptions} txOptions - an options object for the contract deploy\r\n *\r\n * Returns a signed Stacks smart contract deploy transaction.\r\n *\r\n * @return {StacksTransaction}\r\n */\r\nexport async function makeContractDeploy(\r\n  txOptions: SignedContractDeployOptions | SignedMultiSigContractDeployOptions\r\n): Promise<StacksTransaction> {\r\n  if ('senderKey' in txOptions) {\r\n    // txOptions is SignedContractDeployOptions\r\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\r\n    const options = omit(txOptions, 'senderKey');\r\n    const transaction = await makeUnsignedContractDeploy({ publicKey, ...options });\r\n\r\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\r\n    const signer = new TransactionSigner(transaction);\r\n    signer.signOrigin(privKey);\r\n\r\n    return transaction;\r\n  } else {\r\n    // txOptions is SignedMultiSigContractDeployOptions\r\n    const options = omit(txOptions, 'signerKeys');\r\n    const transaction = await makeUnsignedContractDeploy(options);\r\n\r\n    const signer = new TransactionSigner(transaction);\r\n    let pubKeys = txOptions.publicKeys;\r\n    for (const key of txOptions.signerKeys) {\r\n      const pubKey = pubKeyfromPrivKey(key);\r\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\r\n      signer.signOrigin(createStacksPrivateKey(key));\r\n    }\r\n\r\n    for (const key of pubKeys) {\r\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\r\n    }\r\n\r\n    return transaction;\r\n  }\r\n}\r\n\r\nexport async function makeUnsignedContractDeploy(\r\n  txOptions: UnsignedContractDeployOptions | UnsignedMultiSigContractDeployOptions\r\n): Promise<StacksTransaction> {\r\n  const defaultOptions = {\r\n    fee: BigInt(0),\r\n    nonce: BigInt(0),\r\n    network: new StacksMainnet(),\r\n    postConditionMode: PostConditionMode.Deny,\r\n    sponsored: false,\r\n    clarityVersion: ClarityVersion.Clarity2,\r\n  };\r\n\r\n  const options = Object.assign(defaultOptions, txOptions);\r\n\r\n  const payload = createSmartContractPayload(\r\n    options.contractName,\r\n    options.codeBody,\r\n    options.clarityVersion\r\n  );\r\n\r\n  let authorization: Authorization | null = null;\r\n\r\n  let spendingCondition: SpendingCondition | null = null;\r\n\r\n  if ('publicKey' in options) {\r\n    // single-sig\r\n    spendingCondition = createSingleSigSpendingCondition(\r\n      AddressHashMode.SerializeP2PKH,\r\n      options.publicKey,\r\n      options.nonce,\r\n      options.fee\r\n    );\r\n  } else {\r\n    // multi-sig\r\n    spendingCondition = createMultiSigSpendingCondition(\r\n      AddressHashMode.SerializeP2SH,\r\n      options.numSignatures,\r\n      options.publicKeys,\r\n      options.nonce,\r\n      options.fee\r\n    );\r\n  }\r\n\r\n  if (options.sponsored) {\r\n    authorization = createSponsoredAuth(spendingCondition);\r\n  } else {\r\n    authorization = createStandardAuth(spendingCondition);\r\n  }\r\n\r\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\r\n\r\n  const postConditions: PostCondition[] = [];\r\n  if (options.postConditions && options.postConditions.length > 0) {\r\n    options.postConditions.forEach(postCondition => {\r\n      postConditions.push(postCondition);\r\n    });\r\n  }\r\n  const lpPostConditions = createLPList(postConditions);\r\n\r\n  const transaction = new StacksTransaction(\r\n    network.version,\r\n    authorization,\r\n    payload,\r\n    lpPostConditions,\r\n    options.postConditionMode,\r\n    options.anchorMode,\r\n    network.chainId\r\n  );\r\n\r\n  if (txOptions.fee === undefined || txOptions.fee === null) {\r\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\r\n    transaction.setFee(fee);\r\n  }\r\n\r\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\r\n    const addressVersion =\r\n      options.network.version === TransactionVersion.Mainnet\r\n        ? AddressVersion.MainnetSingleSig\r\n        : AddressVersion.TestnetSingleSig;\r\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\r\n    const txNonce = await getNonce(senderAddress, options.network);\r\n    transaction.setNonce(txNonce);\r\n  }\r\n\r\n  return transaction;\r\n}\r\n\r\n/**\r\n * Contract function call transaction options\r\n */\r\nexport interface ContractCallOptions {\r\n  /** the Stacks address of the contract */\r\n  contractAddress: string;\r\n  contractName: string;\r\n  functionName: string;\r\n  functionArgs: ClarityValue[];\r\n  /** transaction fee in microstacks */\r\n  fee?: IntegerType;\r\n  feeEstimateApiUrl?: string;\r\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\r\n  nonce?: IntegerType;\r\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\r\n  network?: StacksNetworkName | StacksNetwork;\r\n  /** the transaction anchorMode, which specifies whether it should be\r\n   * included in an anchor block or a microblock */\r\n  anchorMode: AnchorModeName | AnchorMode;\r\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\r\n   * transfered assets */\r\n  postConditionMode?: PostConditionMode;\r\n  /** a list of post conditions to add to the transaction */\r\n  postConditions?: PostCondition[];\r\n  /** set to true to validate that the supplied function args match those specified in\r\n   * the published contract */\r\n  validateWithAbi?: boolean | ClarityAbi;\r\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\r\n  sponsored?: boolean;\r\n}\r\n\r\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\r\n  publicKey: string;\r\n}\r\n\r\nexport interface SignedContractCallOptions extends ContractCallOptions {\r\n  senderKey: string;\r\n}\r\n\r\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n}\r\n\r\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\r\n  numSignatures: number;\r\n  publicKeys: string[];\r\n  signerKeys: string[];\r\n}\r\n\r\n/**\r\n * @deprecated Use the new {@link estimateTransaction} function insterad.\r\n *\r\n * Estimate the total transaction fee in microstacks for a contract function call\r\n *\r\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\r\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\r\n *\r\n * @return a promise that resolves to number of microstacks per byte\r\n */\r\nexport async function estimateContractFunctionCall(\r\n  transaction: StacksTransaction,\r\n  network?: StacksNetworkName | StacksNetwork\r\n): Promise<bigint> {\r\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\r\n    throw new Error(\r\n      `Contract call fee estimation only possible with ${\r\n        PayloadType[PayloadType.ContractCall]\r\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\r\n    );\r\n  }\r\n\r\n  const requestHeaders = {\r\n    Accept: 'application/text',\r\n  };\r\n\r\n  const fetchOptions = {\r\n    method: 'GET',\r\n    headers: requestHeaders,\r\n  };\r\n\r\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\r\n  // blockchain core\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\r\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\r\n\r\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\r\n  if (!response.ok) {\r\n    const msg = await response.text().catch(() => '');\r\n    throw new Error(\r\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n  const feeRateResult = await response.text();\r\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\r\n  const feeRate = intToBigInt(feeRateResult, false);\r\n  return feeRate * txBytes;\r\n}\r\n\r\n/**\r\n * Generates an unsigned Clarity smart contract function call transaction\r\n *\r\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\r\n *\r\n * @returns {Promise<StacksTransaction>}\r\n */\r\nexport async function makeUnsignedContractCall(\r\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\r\n): Promise<StacksTransaction> {\r\n  const defaultOptions = {\r\n    fee: BigInt(0),\r\n    nonce: BigInt(0),\r\n    network: new StacksMainnet(),\r\n    postConditionMode: PostConditionMode.Deny,\r\n    sponsored: false,\r\n  };\r\n\r\n  const options = Object.assign(defaultOptions, txOptions);\r\n\r\n  const payload = createContractCallPayload(\r\n    options.contractAddress,\r\n    options.contractName,\r\n    options.functionName,\r\n    options.functionArgs\r\n  );\r\n\r\n  if (options?.validateWithAbi) {\r\n    let abi: ClarityAbi;\r\n    if (typeof options.validateWithAbi === 'boolean') {\r\n      if (options?.network) {\r\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\r\n      } else {\r\n        throw new Error('Network option must be provided in order to validate with ABI');\r\n      }\r\n    } else {\r\n      abi = options.validateWithAbi;\r\n    }\r\n\r\n    validateContractCall(payload, abi);\r\n  }\r\n\r\n  let spendingCondition: SpendingCondition | null = null;\r\n  let authorization: Authorization | null = null;\r\n\r\n  if ('publicKey' in options) {\r\n    // single-sig\r\n    spendingCondition = createSingleSigSpendingCondition(\r\n      AddressHashMode.SerializeP2PKH,\r\n      options.publicKey,\r\n      options.nonce,\r\n      options.fee\r\n    );\r\n  } else {\r\n    // multi-sig\r\n    spendingCondition = createMultiSigSpendingCondition(\r\n      AddressHashMode.SerializeP2SH,\r\n      options.numSignatures,\r\n      options.publicKeys,\r\n      options.nonce,\r\n      options.fee\r\n    );\r\n  }\r\n\r\n  if (options.sponsored) {\r\n    authorization = createSponsoredAuth(spendingCondition);\r\n  } else {\r\n    authorization = createStandardAuth(spendingCondition);\r\n  }\r\n\r\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\r\n\r\n  const postConditions: PostCondition[] = [];\r\n  if (options.postConditions && options.postConditions.length > 0) {\r\n    options.postConditions.forEach(postCondition => {\r\n      postConditions.push(postCondition);\r\n    });\r\n  }\r\n\r\n  const lpPostConditions = createLPList(postConditions);\r\n  const transaction = new StacksTransaction(\r\n    network.version,\r\n    authorization,\r\n    payload,\r\n    lpPostConditions,\r\n    options.postConditionMode,\r\n    options.anchorMode,\r\n    network.chainId\r\n  );\r\n\r\n  if (txOptions.fee === undefined || txOptions.fee === null) {\r\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\r\n    transaction.setFee(fee);\r\n  }\r\n\r\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\r\n    const addressVersion =\r\n      network.version === TransactionVersion.Mainnet\r\n        ? AddressVersion.MainnetSingleSig\r\n        : AddressVersion.TestnetSingleSig;\r\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\r\n    const txNonce = await getNonce(senderAddress, network);\r\n    transaction.setNonce(txNonce);\r\n  }\r\n\r\n  return transaction;\r\n}\r\n\r\n/**\r\n * Generates a Clarity smart contract function call transaction\r\n *\r\n * @param {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\r\n *\r\n * Returns a signed Stacks smart contract function call transaction.\r\n *\r\n * @return {StacksTransaction}\r\n */\r\nexport async function makeContractCall(\r\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\r\n): Promise<StacksTransaction> {\r\n  if ('senderKey' in txOptions) {\r\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\r\n    const options = omit(txOptions, 'senderKey');\r\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\r\n\r\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\r\n    const signer = new TransactionSigner(transaction);\r\n    signer.signOrigin(privKey);\r\n\r\n    return transaction;\r\n  } else {\r\n    const options = omit(txOptions, 'signerKeys');\r\n    const transaction = await makeUnsignedContractCall(options);\r\n\r\n    const signer = new TransactionSigner(transaction);\r\n    let pubKeys = txOptions.publicKeys;\r\n    for (const key of txOptions.signerKeys) {\r\n      const pubKey = pubKeyfromPrivKey(key);\r\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\r\n      signer.signOrigin(createStacksPrivateKey(key));\r\n    }\r\n\r\n    for (const key of pubKeys) {\r\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\r\n    }\r\n\r\n    return transaction;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a STX post condition with a standard principal\r\n *\r\n * Returns a STX post condition object\r\n *\r\n * @param address - the c32check address\r\n * @param conditionCode - the condition code\r\n * @param amount - the amount of STX tokens (denoted in micro-STX)\r\n */\r\nexport function makeStandardSTXPostCondition(\r\n  address: string,\r\n  conditionCode: FungibleConditionCode,\r\n  amount: IntegerType\r\n): STXPostCondition {\r\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\r\n}\r\n\r\n/**\r\n * Generates a STX post condition with a contract principal\r\n *\r\n * Returns a STX post condition object\r\n *\r\n * @param address - the c32check address of the contract\r\n * @param contractName - the name of the contract\r\n * @param conditionCode - the condition code\r\n * @param amount - the amount of STX tokens (denoted in micro-STX)\r\n *\r\n * @return {STXPostCondition}\r\n */\r\nexport function makeContractSTXPostCondition(\r\n  address: string,\r\n  contractName: string,\r\n  conditionCode: FungibleConditionCode,\r\n  amount: IntegerType\r\n): STXPostCondition {\r\n  return createSTXPostCondition(\r\n    createContractPrincipal(address, contractName),\r\n    conditionCode,\r\n    amount\r\n  );\r\n}\r\n\r\n/**\r\n * Generates a fungible token post condition with a standard principal\r\n *\r\n * Returns a fungible token post condition object\r\n *\r\n * @param address - the c32check address\r\n * @param conditionCode - the condition code\r\n * @param amount - the amount of fungible tokens (in their respective base unit)\r\n * @param assetInfo - asset info describing the fungible token\r\n */\r\nexport function makeStandardFungiblePostCondition(\r\n  address: string,\r\n  conditionCode: FungibleConditionCode,\r\n  amount: IntegerType,\r\n  assetInfo: string | AssetInfo\r\n): FungiblePostCondition {\r\n  return createFungiblePostCondition(\r\n    createStandardPrincipal(address),\r\n    conditionCode,\r\n    amount,\r\n    assetInfo\r\n  );\r\n}\r\n\r\n/**\r\n * Generates a fungible token post condition with a contract principal\r\n *\r\n * Returns a fungible token post condition object\r\n *\r\n * @param address - the c32check address\r\n * @param contractName - the name of the contract\r\n * @param conditionCode - the condition code\r\n * @param amount - the amount of fungible tokens (in their respective base unit)\r\n * @param assetInfo - asset info describing the fungible token\r\n */\r\nexport function makeContractFungiblePostCondition(\r\n  address: string,\r\n  contractName: string,\r\n  conditionCode: FungibleConditionCode,\r\n  amount: IntegerType,\r\n  assetInfo: string | AssetInfo\r\n): FungiblePostCondition {\r\n  return createFungiblePostCondition(\r\n    createContractPrincipal(address, contractName),\r\n    conditionCode,\r\n    amount,\r\n    assetInfo\r\n  );\r\n}\r\n\r\n/**\r\n * Generates a non-fungible token post condition with a standard principal\r\n *\r\n * Returns a non-fungible token post condition object\r\n *\r\n * @param {String} address - the c32check address\r\n * @param {FungibleConditionCode} conditionCode - the condition code\r\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\r\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\r\n *\r\n * @return {NonFungiblePostCondition}\r\n */\r\nexport function makeStandardNonFungiblePostCondition(\r\n  address: string,\r\n  conditionCode: NonFungibleConditionCode,\r\n  assetInfo: string | AssetInfo,\r\n  assetId: ClarityValue\r\n): NonFungiblePostCondition {\r\n  return createNonFungiblePostCondition(\r\n    createStandardPrincipal(address),\r\n    conditionCode,\r\n    assetInfo,\r\n    assetId\r\n  );\r\n}\r\n\r\n/**\r\n * Generates a non-fungible token post condition with a contract principal\r\n *\r\n * Returns a non-fungible token post condition object\r\n *\r\n * @param {String} address - the c32check address\r\n * @param {String} contractName - the name of the contract\r\n * @param {FungibleConditionCode} conditionCode - the condition code\r\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\r\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\r\n *\r\n * @return {NonFungiblePostCondition}\r\n */\r\nexport function makeContractNonFungiblePostCondition(\r\n  address: string,\r\n  contractName: string,\r\n  conditionCode: NonFungibleConditionCode,\r\n  assetInfo: string | AssetInfo,\r\n  assetId: ClarityValue\r\n): NonFungiblePostCondition {\r\n  return createNonFungiblePostCondition(\r\n    createContractPrincipal(address, contractName),\r\n    conditionCode,\r\n    assetInfo,\r\n    assetId\r\n  );\r\n}\r\n\r\n/**\r\n * Read only function options\r\n *\r\n * @param {String} contractAddress - the c32check address of the contract\r\n * @param {String} contractName - the contract name\r\n * @param {String} functionName - name of the function to be called\r\n * @param {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\r\n * @param {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\r\n * @param {String} senderAddress - the c32check address of the sender\r\n */\r\n\r\nexport interface ReadOnlyFunctionOptions {\r\n  contractName: string;\r\n  contractAddress: string;\r\n  functionName: string;\r\n  functionArgs: ClarityValue[];\r\n  /** the network that the contract which contains the function is deployed to */\r\n  network?: StacksNetworkName | StacksNetwork;\r\n  /** address of the sender */\r\n  senderAddress: string;\r\n}\r\n\r\n/**\r\n * Calls a function as read-only from a contract interface\r\n * It is not necessary that the function is defined as read-only in the contract\r\n *\r\n * @param {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\r\n *\r\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\r\n *\r\n * @return {ClarityValue}\r\n */\r\nexport async function callReadOnlyFunction(\r\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\r\n): Promise<ClarityValue> {\r\n  const defaultOptions = {\r\n    network: new StacksMainnet(),\r\n  };\r\n\r\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\r\n\r\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\r\n\r\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\r\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\r\n\r\n  const args = functionArgs.map(arg => cvToHex(arg));\r\n\r\n  const body = JSON.stringify({\r\n    sender: senderAddress,\r\n    arguments: args,\r\n  });\r\n\r\n  const response = await network.fetchFn(url, {\r\n    method: 'POST',\r\n    body,\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const msg = await response.text().catch(() => '');\r\n    throw new Error(\r\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n\r\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\r\n}\r\n\r\nexport interface GetContractMapEntryOptions {\r\n  /** the contracts address */\r\n  contractAddress: string;\r\n  /** the contracts name */\r\n  contractName: string;\r\n  /** the map name */\r\n  mapName: string;\r\n  /** key to lookup in the map */\r\n  mapKey: ClarityValue;\r\n  /** the network that has the contract */\r\n  network?: StacksNetworkName | StacksNetwork;\r\n}\r\n\r\n/**\r\n * Fetch data from a contract data map.\r\n * @param getContractMapEntryOptions - the options object\r\n * @returns\r\n * Promise that resolves to a ClarityValue if the operation succeeds.\r\n * Resolves to NoneCV if the map does not contain the given key, if the map does not exist, or if the contract prinicipal does not exist\r\n */\r\nexport async function getContractMapEntry<T extends ClarityValue = ClarityValue>(\r\n  getContractMapEntryOptions: GetContractMapEntryOptions\r\n): Promise<T | NoneCV> {\r\n  const defaultOptions = {\r\n    network: new StacksMainnet(),\r\n  };\r\n  const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(\r\n    defaultOptions,\r\n    getContractMapEntryOptions\r\n  );\r\n\r\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\r\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\r\n\r\n  const serializedKeyBytes = serializeCV(mapKey);\r\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\r\n\r\n  const fetchOptions: RequestInit = {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      Accept: 'application/json',\r\n    },\r\n    body: JSON.stringify(serializedKeyHex), // endpoint expects a JSON string atom (quote wrapped string)\r\n  };\r\n\r\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\r\n  if (!response.ok) {\r\n    const msg = await response.text().catch(() => '');\r\n    throw new Error(\r\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\r\n    );\r\n  }\r\n  const responseBody = await response.text();\r\n  const responseJson: { data?: string } = JSON.parse(responseBody);\r\n  if (!responseJson.data) {\r\n    throw new Error(\r\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`\r\n    );\r\n  }\r\n  let deserializedCv: T;\r\n  try {\r\n    deserializedCv = deserializeCV<T>(responseJson.data);\r\n  } catch (error) {\r\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\r\n  }\r\n  return deserializedCv;\r\n}\r\n\r\n/**\r\n * Sponsored transaction options\r\n */\r\nexport interface SponsorOptionsOpts {\r\n  /** the origin-signed transaction */\r\n  transaction: StacksTransaction;\r\n  /** the sponsor's private key */\r\n  sponsorPrivateKey: string;\r\n  /** the transaction fee amount to sponsor */\r\n  fee?: IntegerType;\r\n  /** the nonce of the sponsor account */\r\n  sponsorNonce?: IntegerType;\r\n  /** the hashmode of the sponsor's address */\r\n  sponsorAddressHashmode?: AddressHashMode;\r\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\r\n  network?: StacksNetworkName | StacksNetwork;\r\n}\r\n\r\n/**\r\n * Constructs and signs a sponsored transaction as the sponsor\r\n *\r\n * @param {SponsorOptionsOpts} sponsorOptions - the sponsor options object\r\n *\r\n * Returns a signed sponsored transaction.\r\n *\r\n * @return {ClarityValue}\r\n */\r\nexport async function sponsorTransaction(\r\n  sponsorOptions: SponsorOptionsOpts\r\n): Promise<StacksTransaction> {\r\n  const defaultOptions = {\r\n    fee: 0 as IntegerType,\r\n    sponsorNonce: 0 as IntegerType,\r\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\r\n    network:\r\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\r\n        ? new StacksMainnet()\r\n        : new StacksTestnet(),\r\n  };\r\n\r\n  const options = Object.assign(defaultOptions, sponsorOptions);\r\n\r\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\r\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\r\n\r\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\r\n    let txFee = 0;\r\n    switch (options.transaction.payload.payloadType) {\r\n      case PayloadType.TokenTransfer:\r\n      case PayloadType.SmartContract:\r\n      case PayloadType.VersionedSmartContract:\r\n      case PayloadType.ContractCall:\r\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\r\n        try {\r\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\r\n            .fee;\r\n        } catch (e) {\r\n          throw e;\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          `Sponsored transactions not supported for transaction type ${\r\n            PayloadType[options.transaction.payload.payloadType]\r\n          }`\r\n        );\r\n    }\r\n    options.transaction.setFee(txFee);\r\n    options.fee = txFee;\r\n  }\r\n\r\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\r\n    const addressVersion =\r\n      network.version === TransactionVersion.Mainnet\r\n        ? AddressVersion.MainnetSingleSig\r\n        : AddressVersion.TestnetSingleSig;\r\n\r\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\r\n    const sponsorNonce = await getNonce(senderAddress, network);\r\n    options.sponsorNonce = sponsorNonce;\r\n  }\r\n\r\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\r\n    options.sponsorAddressHashmode,\r\n    publicKeyToString(sponsorPubKey),\r\n    options.sponsorNonce,\r\n    options.fee\r\n  );\r\n\r\n  options.transaction.setSponsor(sponsorSpendingCondition);\r\n\r\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\r\n  const signer = TransactionSigner.createSponsorSigner(\r\n    options.transaction,\r\n    sponsorSpendingCondition\r\n  );\r\n  signer.signSponsor(privKey);\r\n\r\n  return signer.transaction;\r\n}\r\n\r\n/**\r\n * Estimates transaction byte length\r\n * Context:\r\n * 1) Multi-sig transaction byte length increases by adding signatures\r\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\r\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\r\n * @param {transaction} - StacksTransaction object to be estimated\r\n * @return {number} Estimated transaction byte length\r\n */\r\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\r\n  const hashMode = transaction.auth.spendingCondition.hashMode;\r\n  // List of Multi-sig transaction hash modes\r\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\r\n\r\n  // Check if its a Multi-sig transaction\r\n  if (multiSigHashModes.includes(hashMode)) {\r\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\r\n      .spendingCondition as MultiSigSpendingCondition;\r\n\r\n    // Find number of existing signatures if the transaction is signed or partially signed\r\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\r\n      field => field.contents.type === StacksMessageType.MessageSignature\r\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\r\n\r\n    // Estimate total signature bytes size required for this multi-sig transaction\r\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\r\n    const totalSignatureLength =\r\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\r\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\r\n\r\n    return transaction.serialize().byteLength + totalSignatureLength;\r\n  } else {\r\n    // Single-sig transaction\r\n    // Signature space already allocated by empty message signature\r\n    return transaction.serialize().byteLength;\r\n  }\r\n}\r\n\r\n/**\r\n * Estimates the fee using {@link estimateTransfer} as a fallback if\r\n * {@link estimateTransaction} does not get an estimation due to the\r\n * {@link NoEstimateAvailableError} error.\r\n */\r\nexport async function estimateTransactionFeeWithFallback(\r\n  transaction: StacksTransaction,\r\n  network: StacksNetwork\r\n): Promise<bigint | number> {\r\n  try {\r\n    const estimatedLen = estimateTransactionByteLength(transaction);\r\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\r\n  } catch (error) {\r\n    if (error instanceof NoEstimateAvailableError) {\r\n      return await estimateTransferUnsafe(transaction, network);\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}