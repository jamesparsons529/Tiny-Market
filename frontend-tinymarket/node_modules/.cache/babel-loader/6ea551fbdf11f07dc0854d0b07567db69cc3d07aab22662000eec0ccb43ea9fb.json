{"ast":null,"code":"// Fetch NFTs for the user's Stacks address\nuseEffect(() => {\n  async function fetchNFTs() {\n    try {\n      setLoading(true);\n\n      // Fetch NFTs from the Hiro Stacks API\n      const response = await fetch(`https://stacks-node-api.mainnet.stacks.co/extended/v1/tokens/nft/holdings?principal=${stxAddress}`);\n      const data = await response.json();\n      console.log(data);\n\n      // Check if data exists and set it to state\n      if (data.results && data.results.length > 0) {\n        const nftsWithDetails = await Promise.all(data.results.map(async nft => {\n          const {\n            principal,\n            contractName\n          } = extractPrincipalAndContract(nft.asset_identifier);\n          const tokenId = nft.value.repr.replace('u', ''); // Extract token ID\n\n          console.log(`Principal: ${principal}`);\n          console.log(`Contract Name: ${contractName}`);\n          console.log(`Token ID: ${tokenId}`);\n\n          // Define the contract and function to call\n          const network = new StacksMainnet();\n          const tokenUriFunction = 'get-token-uri'; // Replace with the actual function name if different\n          const functionArgs = [uintCV(tokenId)]; // Pass Token ID\n\n          // Call the contract function\n          try {\n            const result = await callReadOnlyFunction({\n              contractAddress: principal,\n              contractName: contractName,\n              functionName: tokenUriFunction,\n              functionArgs: functionArgs,\n              network,\n              senderAddress: stxAddress\n            });\n            console.log(result);\n            const tokenUri = result.value.value.data || ''; // Adjust if the result structure is different\n            console.log(`Token URI: ${tokenUri}`);\n            let imageUrl = '';\n\n            // Fetch and parse the JSON if tokenUri is a URL\n            if (tokenUri.startsWith('http')) {\n              try {\n                const jsonResponse = await fetch(tokenUri);\n                const jsonData = await jsonResponse.json();\n                imageUrl = jsonData.image || ''; // Adjust according to the JSON structure\n              } catch (jsonError) {\n                console.error('Error fetching or parsing JSON:', jsonError);\n              }\n            } else {\n              // Convert IPFS URL to HTTP URL\n              imageUrl = tokenUri.startsWith('ipfs://') ? convertIpfsUrl(tokenUri) : tokenUri;\n            }\n            console.log(`Image URL: ${imageUrl}`);\n            return {\n              ...nft,\n              principal,\n              contractName,\n              tokenId,\n              imageUrl\n            };\n          } catch (error) {\n            console.error('Error calling contract function:', error);\n            return {\n              ...nft,\n              principal,\n              contractName,\n              tokenId,\n              imageUrl: ''\n            };\n          }\n        }));\n        setNfts(nftsWithDetails);\n      } else {\n        console.log('No NFTs found for this address.');\n      }\n      setLoading(false);\n    } catch (error) {\n      console.error('Error fetching NFTs:', error);\n      setLoading(false);\n    }\n  }\n  fetchNFTs();\n}, [stxAddress]);","map":{"version":3,"names":["useEffect","fetchNFTs","setLoading","response","fetch","stxAddress","data","json","console","log","results","length","nftsWithDetails","Promise","all","map","nft","principal","contractName","extractPrincipalAndContract","asset_identifier","tokenId","value","repr","replace","network","StacksMainnet","tokenUriFunction","functionArgs","uintCV","result","callReadOnlyFunction","contractAddress","functionName","senderAddress","tokenUri","imageUrl","startsWith","jsonResponse","jsonData","image","jsonError","error","convertIpfsUrl","setNfts"],"sources":["C:/Users/Elliott/Tiny-Market/frontend-tinymarket/src/components/AssetCard.js"],"sourcesContent":["// Fetch NFTs for the user's Stacks address\r\nuseEffect(() => {\r\n  async function fetchNFTs() {\r\n    try {\r\n      setLoading(true);\r\n\r\n      // Fetch NFTs from the Hiro Stacks API\r\n      const response = await fetch(\r\n        `https://stacks-node-api.mainnet.stacks.co/extended/v1/tokens/nft/holdings?principal=${stxAddress}`\r\n      );\r\n      const data = await response.json();\r\n\r\n      console.log(data);\r\n      \r\n      // Check if data exists and set it to state\r\n      if (data.results && data.results.length > 0) {\r\n        const nftsWithDetails = await Promise.all(data.results.map(async (nft) => {\r\n          const { principal, contractName } = extractPrincipalAndContract(nft.asset_identifier);\r\n          const tokenId = nft.value.repr.replace('u', ''); // Extract token ID\r\n\r\n          console.log(`Principal: ${principal}`);\r\n          console.log(`Contract Name: ${contractName}`);\r\n          console.log(`Token ID: ${tokenId}`);\r\n\r\n          // Define the contract and function to call\r\n          const network = new StacksMainnet();\r\n          const tokenUriFunction = 'get-token-uri'; // Replace with the actual function name if different\r\n          const functionArgs = [uintCV(tokenId)]; // Pass Token ID\r\n\r\n          // Call the contract function\r\n          try {\r\n            const result = await callReadOnlyFunction({\r\n              contractAddress: principal,\r\n              contractName: contractName,\r\n              functionName: tokenUriFunction,\r\n              functionArgs: functionArgs,\r\n              network,\r\n              senderAddress: stxAddress\r\n            });\r\n            console.log(result);\r\n            const tokenUri = result.value.value.data || ''; // Adjust if the result structure is different\r\n            console.log(`Token URI: ${tokenUri}`);\r\n\r\n            let imageUrl = '';\r\n\r\n            // Fetch and parse the JSON if tokenUri is a URL\r\n            if (tokenUri.startsWith('http')) {\r\n              try {\r\n                const jsonResponse = await fetch(tokenUri);\r\n                const jsonData = await jsonResponse.json();\r\n                imageUrl = jsonData.image || ''; // Adjust according to the JSON structure\r\n              } catch (jsonError) {\r\n                console.error('Error fetching or parsing JSON:', jsonError);\r\n              }\r\n            } else {\r\n              // Convert IPFS URL to HTTP URL\r\n              imageUrl = tokenUri.startsWith('ipfs://') ? convertIpfsUrl(tokenUri) : tokenUri;\r\n            }\r\n\r\n            console.log(`Image URL: ${imageUrl}`);\r\n            \r\n            return {\r\n              ...nft,\r\n              principal,\r\n              contractName,\r\n              tokenId,\r\n              imageUrl\r\n            };\r\n          } catch (error) {\r\n            console.error('Error calling contract function:', error);\r\n            return {\r\n              ...nft,\r\n              principal,\r\n              contractName,\r\n              tokenId,\r\n              imageUrl: ''\r\n            };\r\n          }\r\n        }));\r\n        setNfts(nftsWithDetails);\r\n      } else {\r\n        console.log('No NFTs found for this address.');\r\n      }\r\n\r\n      setLoading(false);\r\n    } catch (error) {\r\n      console.error('Error fetching NFTs:', error);\r\n      setLoading(false);\r\n    }\r\n  }\r\n\r\n  fetchNFTs();\r\n}, [stxAddress]); \r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}