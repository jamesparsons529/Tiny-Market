import { authenticate, makeStxTransferToken, makeContractCallToken, makeContractDeployToken, openTransactionPopup, handleSignMessageRequest, handleSignStructuredDataRequest, hashMessage, recoverSignature, getPublicKeyFromSignature, verifyMessageSignature } from 'micro-stacks/connect';
import { StacksMainnet, StacksTestnet, ChainID } from 'micro-stacks/network';
import Lt from 'zustand/vanilla';
import { subscribeWithSelector, persist } from 'zustand/middleware';
import { hexToBytes, fetchPrivate, getGlobalObject, bytesToHex } from 'micro-stacks/common';
import et from 'tiny-invariant';
import { c32address, StacksNetworkVersion, privateKeyToBase58Address, c32addressDecode, encryptContent, decryptContent, publicKeyToStxAddress, validateStacksAddress } from 'micro-stacks/crypto';
import { generateGaiaHubConfigSync, putFile, getFile } from 'micro-stacks/storage';
import I from 'fast-deep-equal/es6/index.js';

var Q="micro-stacks",M={getItem:n=>null,setItem:(n,t)=>{},removeItem:n=>{}},V=tt({storage:typeof window<"u"?window.localStorage:M,serialize:JSON.stringify,deserialize:JSON.parse});function tt({storage:n,key:t=Q,serialize:e,deserialize:s}){return {...n,getItem:(i,r=null)=>{let o=`${t}.${i.replace(`${t}.`,"")}`,a=n.getItem(o);if(!s)return a??r;try{return a?s(a):r}catch(d){return console.warn(d),r}},setItem:(i,r)=>{let o=`${t}.${i.replace(`${t}.`,"")}`;if(r===null)n.removeItem(o);else try{let a=e?e(r):r;n.setItem(o,a);}catch(a){console.error(a);}},removeItem:i=>n.removeItem(`${t}.${i}`)}}function st(n){return `[@micro-stacks/client] ${n}`}function h(n,t){et(n,st(t));}var U=(s=>(s.ContractCall="contract_call",s.TokenTransfer="token_transfer",s.ContractDeploy="contract_deploy",s))(U||{}),F=(i=>(i.Authentication="status/Authentication",i.TransactionSigning="status/TransactionSigning",i.MessageSigning="status/MessageSigning",i.StructuredMessageSigning="status/StructuredMessageSigning",i))(F||{}),B=(e=>(e.IsLoading="status/IsLoading",e.IsIdle="status/IsIdle",e))(B||{}),P="store",C=typeof document>"u";var nt=function(n){var t=n.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);return t};function A(n){if(!!n&&!/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(n)&&!/%[^0-9a-f]/i.test(n)&&!/%[0-9a-f](:?[^0-9a-f]|$)/i.test(n)){var t=[],e="",s="",i="",r="",o="",a="";if(t=nt(n),e=t[1],s=t[2],i=t[3],r=t[4],o=t[5],!!(e&&e.length&&i.length>=0)){if(s&&s.length){if(!(i.length===0||/^\//.test(i)))return}else if(/^\/\//.test(i))return;if(!!/^[a-z][a-z0-9\+\-\.]*$/.test(e.toLowerCase()))return a+=e+":",s&&s.length&&(a+="//"+s),a+=i,r&&r.length&&(a+="?"+r),o&&o.length&&(a+="#"+o),a}}}var rt="(?<domain>([^?#]*)) wants you to sign in with your Stacks account:",ot="\\n(?<address>S[A-Z0-9]{40})\\n\\n",at="((?<statement>[^\\n]+)\\n)?",z="(([^:?#]+):)?(([^?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",ct=`\\nURI: (?<uri>${z}?)`,dt="\\nVersion: (?<version>1)",ut="\\nChain ID: (?<chainId>[0-9]+)",lt="\\nNonce: (?<nonce>[a-zA-Z0-9]{8,})",b="([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))",ht=`\\nIssued At: (?<issuedAt>${b})`,gt=`(\\nExpiration Time: (?<expirationTime>${b}))?`,St=`(\\nNot Before: (?<notBefore>${b}))?`,ft="(\\nRequest ID: (?<requestId>[-._~!$&'()*+,;=:@%a-zA-Z0-9]*))?",pt=`(\\nResources:(?<resources>(\\n- ${z}?)+))?`,It=`^${rt}${ot}${at}${ct}${dt}${ut}${lt}${ht}${gt}${St}${ft}${pt}$`,m=class{domain;address;statement;uri;version;chainId;nonce;issuedAt;expirationTime;notBefore;requestId;resources;match;constructor(t){var i,r,o,a,d,u,S,l,c,g,v,D,R,$;let s=new RegExp(It,"g").exec(t);if(!s)throw new Error("Message did not match the regular expression.");if(this.match=s,this.domain=(i=s==null?void 0:s.groups)==null?void 0:i.domain,this.domain.length===0||!/[^#?]*/.test(this.domain))throw new Error("Domain cannot be empty.");if(this.address=(r=s==null?void 0:s.groups)==null?void 0:r.address,!validateStacksAddress(this.address))throw new Error("Invalid address.");if(this.statement=(o=s==null?void 0:s.groups)==null?void 0:o.statement,this.uri=(a=s==null?void 0:s.groups)==null?void 0:a.uri,!A(this.uri))throw new Error("Invalid URI.");this.version=(d=s==null?void 0:s.groups)==null?void 0:d.version,this.nonce=(u=s==null?void 0:s.groups)==null?void 0:u.nonce,this.chainId=parseInt((S=s==null?void 0:s.groups)==null?void 0:S.chainId),this.issuedAt=(l=s==null?void 0:s.groups)==null?void 0:l.issuedAt,this.expirationTime=(c=s==null?void 0:s.groups)==null?void 0:c.expirationTime,this.notBefore=(g=s==null?void 0:s.groups)==null?void 0:g.notBefore,this.requestId=(v=s==null?void 0:s.groups)==null?void 0:v.requestId,this.resources=(R=(D=s==null?void 0:s.groups)==null?void 0:D.resources)==null?void 0:R.split(`
- `).slice(1),(($=this.resources)==null?void 0:$.length)>0&&this.resources.forEach(K=>{if(!A(K))throw new Error(`${K} is not a valid resource.`)});}};var q=["signature","domain","nonce","time"],f=class{constructor(t,e,s){this.type=t,this.expected=e,this.received=s;}type;expected;received};var w=class{domain;address;statement;uri;version;chainId;nonce;issuedAt;expirationTime;notBefore;requestId;resources;constructor(t){typeof t=="string"&&(t=new m(t)),this.domain=t.domain,this.address=t.address,this.statement=t.statement,this.uri=t.uri,this.version=t.version,this.nonce=t.nonce,this.issuedAt=t.issuedAt,this.expirationTime=t.expirationTime,this.notBefore=t.notBefore,this.requestId=t.requestId,this.chainId=t.chainId,this.resources=t.resources,typeof this.chainId=="string"&&(this.chainId=parseInt(this.chainId)),this.validateMessage();}toMessage(){this.validateMessage();let t=`${this.domain} wants you to sign in with your Stacks account:`,e=`URI: ${this.uri}`,s=[t,this.address].join(`
`),i=`Version: ${this.version}`,r="Chain ID: "+this.chainId||"1",o=`Nonce: ${this.nonce}`,a=[e,i,r,o];if(this.issuedAt&&Date.parse(this.issuedAt),this.issuedAt=this.issuedAt?this.issuedAt:new Date().toISOString(),a.push(`Issued At: ${this.issuedAt}`),this.expirationTime){let u=`Expiration Time: ${this.expirationTime}`;a.push(u);}this.notBefore&&a.push(`Not Before: ${this.notBefore}`),this.requestId&&a.push(`Request ID: ${this.requestId}`),this.resources&&a.push(["Resources:",...this.resources.map(u=>`- ${u}`)].join(`
`));let d=a.join(`
`);return s=[s,this.statement].join(`

`),this.statement&&(s+=`
`),[s,d].join(`
`)}prepareMessage(){let t;switch(this.version){case"1":{t=this.toMessage();break}default:{t=this.toMessage();break}}return t}async verify(t){return new Promise(async(e,s)=>{Object.keys(t).forEach(c=>{q.includes(c)||s({success:!1,data:this,error:new Error(`${c} is not a valid key for VerifyParams.`)});});let i=c=>{s(c);},{signature:r,domain:o,nonce:a,time:d}=t;o&&o!==this.domain&&i({success:!1,data:this,error:new f("Domain do not match provided domain for verification.",o,this.domain)}),a&&a!==this.nonce&&i({success:!1,data:this,error:new f("Nonce do not match provided nonce for verification.",a,this.nonce)});let u=new Date(d||new Date);if(this.expirationTime){let c=new Date(this.expirationTime);u.getTime()>=c.getTime()&&i({success:!1,data:this,error:new f("Expired message.",`${u.toISOString()} < ${c.toISOString()}`,`${u.toISOString()} >= ${c.toISOString()}`)});}if(this.notBefore){let c=new Date(this.notBefore);u.getTime()<c.getTime()&&i({success:!1,data:this,error:new f("Message is not valid yet.",`${u.toISOString()} >= ${c.toISOString()}`,`${u.toISOString()} < ${c.toISOString()}`)});}let S;try{S=this.prepareMessage();}catch(c){i({success:!1,data:this,error:c});return}let l;try{let c=hashMessage(S),g=recoverSignature({signature:r}),v=getPublicKeyFromSignature({hash:c,signature:g.signature,recoveryBytes:g.recoveryBytes});verifyMessageSignature({signature:r,message:c})&&(l=publicKeyToStxAddress(v,c32addressDecode(this.address)[0]));}catch{}finally{l!==this.address&&i({success:!1,data:this,error:new f("Signature do not match address of the message.",l,`Resolved address to be ${this.address}`)});}e({success:!0,data:this});})}validateMessage(...t){var i;if(t.length>0)throw new f("Unable to parse the message.","Unexpected argument in the validateMessage function.");if(!this.domain||this.domain.length===0||!/[^#?]*/.test(this.domain))throw new f("Invalid domain.",`${this.domain} to be a valid domain.`);if(!validateStacksAddress(this.address))throw new f("Invalid address.",`${this.address} to be a valid address.`);if(!A(this.uri))throw new f("URI does not conform to RFC 3986.",`${this.uri} to be a valid uri.`);if(this.version!=="1")throw new f("Invalid message version.","1",this.version);let e=(i=this==null?void 0:this.nonce)==null?void 0:i.match(/[a-zA-Z0-9]{8,}/);if(!e||this.nonce.length<8||e[0]!==this.nonce)throw new f("Nonce size smaller then 8 characters or is not alphanumeric.",`Length > 8 (${e==null?void 0:e.length}). Alphanumeric.`,this.nonce);let s=/([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])|([+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))/;if(this.issuedAt&&!s.test(this.issuedAt))throw new Error("Invalid time format.");if(this.expirationTime&&!s.test(this.expirationTime))throw new Error("Invalid time format.");if(this.notBefore&&!s.test(this.notBefore))throw new Error("Invalid time format.")}};var y=1;function O({state:n,version:t}){var e,s,i;return JSON.stringify([[(e=n.network)==null?void 0:e.chainId,(i=(s=n.network)==null?void 0:s.getCoreApiUrl)==null?void 0:i.call(s)],[n.currentAccountIndex,n.accounts.map(r=>({appPrivateKey:r.appPrivateKey,address:c32address(r.address[0],hexToBytes(r.address[1])),profile_url:r.profile_url}))],t])}function Et(n){let t=JSON.parse(n),[e,s]=t[0],[i,r]=t[1],o=t[2]??y;return {network:e===ChainID.Mainnet?new StacksMainnet({url:s}):new StacksTestnet({url:s}),currentAccountIndex:i,accounts:r.map(d=>{let[u,S]=c32addressDecode(d.address);return {appPrivateKey:d.appPrivateKey,address:[u,bytesToHex(S)],profile_url:d.profile_url}}),version:o}}var Ot=n=>typeof n!="string"?n:n==="testnet"?new StacksTestnet:new StacksMainnet,k=({network:n=new StacksMainnet,...t})=>({statuses:{["status/Authentication"]:"status/IsIdle",["status/TransactionSigning"]:"status/IsIdle",["status/MessageSigning"]:"status/IsIdle",["status/StructuredMessageSigning"]:"status/IsIdle"},network:Ot(n),appName:t.appName,appIconUrl:t.appIconUrl,accounts:[],currentAccountIndex:0,onPersistState:t.onPersistState,onAuthentication:t.onAuthentication,onNoWalletFound:t.onNoWalletFound,onSignOut:t.onSignOut}),x=(n,t)=>{try{let{version:e,...s}=Et(n);return {state:{...k(t),...s},version:e}}catch{return {state:k(t),version:y}}},W=()=>{if(!getGlobalObject("localStorage",{throwIfUnavailable:!1}))return;let t=localStorage.getItem("MICRO_STACKS_DEBUG");if(t)return JSON.parse(t)};function Tt(n){if(!n)return null;let t=JSON.parse(n);return JSON.stringify([t[0],[t[1][0],t[1][1].map(e=>({...e,appPrivateKey:null}))],t[2]])}var N=class{config;storage;store;debug;fetcher;constructor(t={}){let e={storage:(t==null?void 0:t.storage)??V,network:(t==null?void 0:t.network)??new StacksMainnet,...t},s=typeof e.dehydratedState=="function"?e.dehydratedState(this.storeKey):e.dehydratedState,i=s?x(s,e):{state:k(e),version:y};this.store=Lt(subscribeWithSelector(persist(()=>i.state,{name:P,getStorage:()=>e.storage,version:i.version,serialize:({state:r,version:o})=>O({state:r,version:o??y}),deserialize:r=>x(r,e)}))),this.debug=W(),this.config=e,this.storage=e.storage,this.fetcher=e.fetcher||fetchPrivate;}getState=()=>this.store.getState();setState(t){let e=typeof t=="function"?t(this.store.getState()):t;this.store.setState(e,!0);}resetState(){this.setState(t=>({...t,accounts:[],currentAccountIndex:0}));}get subscribe(){return this.store.subscribe}onStorageUpdate=t=>{if(typeof document<"u"){let e=window.location.host,s=new URL(t.url).host,i=e===s,r=t.key==="micro-stacks.store";if(i&&r){let o=t.newValue;this.hydrate(JSON.parse(o));}}};tabSyncSubscription=t=>{let e=typeof document<"u";return e&&t&&window.addEventListener("storage",this.onStorageUpdate),()=>{e&&t&&window.removeEventListener("storage",this.onStorageUpdate);}};getStacksProvider(){return getGlobalObject("StacksProvider",{throwIfUnavailable:!1})}subscribeToStacksProvider(t,e=100){if(this.getStacksProvider())return t(),()=>{};{let s=setInterval(()=>{!!this.getStacksProvider()&&(t(),clearInterval(s));},e);return ()=>{typeof s<"u"&&clearInterval(s);}}}get storeKey(){return P}onPersistState=t=>{var e,s;return (s=(e=this.store.getState())==null?void 0:e.onPersistState)==null?void 0:s.call(e,t)};get onAuthentication(){var t;return (t=this.store.getState())==null?void 0:t.onAuthentication}get onNoWalletFound(){var t;return (t=this.store.getState())==null?void 0:t.onNoWalletFound}get onSignOut(){var t;return (t=this.store.getState())==null?void 0:t.onSignOut}setOnPersistState=t=>{this.setState(e=>({...e,onPersistState:t})),this.config.onPersistState=t;};setOnNoWalletFound=t=>{this.setState(e=>({...e,onNoWalletFound:t})),this.config.onPersistState=t;};setOnSignOut=t=>{this.setState(e=>({...e,onSignOut:t})),this.config.onSignOut=t;};setOnAuthentication=t=>{this.setState(e=>({...e,onAuthentication:t})),this.config.onAuthentication=t;};persist=async()=>{if(this.onPersistState){let t=this.dehydrate(this.store.getState());await this.onPersistState(t);}};dehydrate(t){return O({state:t??this.store.getState(),version:y})}hydrate(t){let e=x(t,this.config);this.setState(e.state);}selectHasSession=t=>Boolean(t.accounts.length);selectAccounts=t=>t.accounts;selectAccount=t=>this.selectHasSession(t)?t.accounts[t.currentAccountIndex]:void 0;selectNetwork=t=>t.network;selectNetworkChain=t=>t.network.chainId===ChainID.Mainnet?"mainnet":"testnet";selectTestnetStxAddress=t=>{let e=this.selectAccount(t);return e?c32address(e.address[0]===StacksNetworkVersion.mainnetP2SH?StacksNetworkVersion.testnetP2SH:StacksNetworkVersion.testnetP2PKH,hexToBytes(e.address[1])):void 0};selectMainnetStxAddress=t=>{let e=this.selectAccount(t);return e?c32address(e.address[0],hexToBytes(e.address[1])):void 0};selectStxAddress=t=>this.selectNetworkChain(t)==="mainnet"?this.selectMainnetStxAddress(t):this.selectTestnetStxAddress(t);selectAppDetails=t=>t.appName&&t.appIconUrl?{name:t.appName,icon:t.appIconUrl}:void 0;selectIdentityAddress=t=>{let e=this.selectAccount(t);return e!=null&&e.appPrivateKey?privateKeyToBase58Address(e.appPrivateKey):void 0};selectDecentralizedID=t=>{let e=this.selectIdentityAddress(t);return e?`did:btc-addr:${e}`:void 0};selectStatuses=t=>t.statuses;setStatus(t,e){this.setState(s=>({...s,statuses:{...s.statuses,[t]:e}}));}setIsRequestPending(t){this.setStatus(t,"status/IsLoading");}setIsIdle(t){this.setStatus(t,"status/IsIdle");}statuses=()=>this.selectStatuses(this.getState());isSignMessageRequestPending=()=>this.statuses()["status/MessageSigning"];isSignStructuredMessageRequestPending=()=>this.statuses()["status/StructuredMessageSigning"];handleNoStacksProviderFound(){return typeof this.getStacksProvider()>"u"?typeof this.onNoWalletFound<"u"?(this.onNoWalletFound(),!1):(h(this.getStacksProvider(),"The injected `StacksProvider` cannot be found. This is typically because there is no Stacks wallet available, such as the Hiro web wallet extension or the iOS/Android wallet Xverse."),!1):!0}authenticate=async t=>{if(!this.handleNoStacksProviderFound())return;let e=this.selectAppDetails(this.getState());h(e,"App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config.");let s=this.selectAccounts(this.getState());this.setIsRequestPending("status/Authentication"),await authenticate({appDetails:e,onFinish:async({profile:i,...r})=>{var S,l;let[o,a]=c32addressDecode(r.addresses.mainnet),d=[o,bytesToHex(a)];s.find(c=>c.address===d)?this.setState(c=>({...c,currentAccountIndex:s.findIndex(g=>g.address===d)})):this.setState(c=>{var g;return {...c,accounts:c.accounts.concat({address:d,appPrivateKey:(g=this.debug)!=null&&g.disableAppPrivateKey?void 0:r.appPrivateKey,decentralizedID:r.decentralizedID,profile_url:r.profile_url}),currentAccountIndex:c.accounts.length}}),(S=t==null?void 0:t.onFinish)==null||S.call(t,r),(l=this.onAuthentication)==null||l.call(this,{profile:i,...r}),await this.persist(),this.setIsIdle("status/Authentication");},onCancel:i=>{var r;this.setIsIdle("status/Authentication"),(r=t==null?void 0:t.onCancel)==null||r.call(t,i);}},M);};signOut=async t=>{var e,s,i,r;return (i=(s=(e=this.store)==null?void 0:e.persist)==null?void 0:s.clearStorage)==null||i.call(s),(r=this.onSignOut)==null||r.call(this),this.resetState(),t==null?void 0:t()};getSignInMessage=({domain:t,nonce:e,version:s="1.0.0"})=>{if(!this.handleNoStacksProviderFound())return;let i=this.getState(),r=this.selectAppDetails(i),o=this.selectStxAddress(i);h(r,"App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."),h(o,"No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in.");let a=getGlobalObject("document",{throwIfUnavailable:!1})?window.location.origin:"";return new w({domain:r.name,address:o,statement:"Sign in with Stacks",uri:t??a,version:s,chainId:ChainID.Mainnet,nonce:e})};signTransaction=async(t,e)=>{if(!this.handleNoStacksProviderFound())return;let s=this.getState(),i=this.selectAppDetails(s),r=this.selectStxAddress(s),o=this.selectAccount(s),a=this.selectNetwork(s);h(i,"App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."),h(r,"No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."),h(o,"There is not current user session available. Please make sure the user has signed in before attempting this action."),this.setIsRequestPending("status/TransactionSigning");let d,u={privateKey:o.appPrivateKey,appDetails:i,stxAddress:r,network:a,postConditionMode:e.postConditionMode,postConditions:e.postConditions,attachment:e.attachment,sponsored:e.sponsored},l=await(t==="token_transfer"?makeStxTransferToken:t==="contract_call"?makeContractCallToken:makeContractDeployToken)({...u,...e});return h(l,"Transaction JWT could not be created"),await openTransactionPopup({token:l,onFinish:c=>{var g;d=c,(g=e==null?void 0:e.onFinish)==null||g.call(e,c),this.setIsIdle("status/TransactionSigning");},onCancel:c=>{var g;(g=e==null?void 0:e.onCancel)==null||g.call(e,c),this.setIsIdle("status/TransactionSigning");}}),d};signMessage=async t=>{if(!this.handleNoStacksProviderFound())return;let e=this.getState(),s=this.selectAppDetails(e),i=this.selectStxAddress(e),r=this.selectAccount(e),o=this.selectNetwork(e);h(s,"App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."),h(i,"No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."),h(r,"There is not current user session available. Please make sure the user has signed in before attempting this action."),h(t.message,"No message found -- a message is required when requesting a message signature."),this.setIsRequestPending("status/MessageSigning");let a;return await handleSignMessageRequest({appDetails:s,privateKey:r.appPrivateKey,stxAddress:i,network:o,message:t.message,onFinish:d=>{var u;a=d,(u=t==null?void 0:t.onFinish)==null||u.call(t,d),this.setIsIdle("status/MessageSigning");},onCancel:d=>{var u;(u=t==null?void 0:t.onCancel)==null||u.call(t,d),this.setIsIdle("status/MessageSigning");}}),a};signStructuredMessage=async t=>{var d,u,S;if(!this.handleNoStacksProviderFound())return;let e=this.getState(),s=this.selectAppDetails(e),i=this.selectStxAddress(e),r=this.selectAccount(e),o=this.selectNetwork(e);h(s,"App details are not defined for you app. Most functionality (authentication, signing requests) require details be passed to the wallet. Add them to your MicroStacksClient config."),h(i,"No current Stacks address can be found. This could be because a session has been invalidated, or the user is not signed in."),h(r,"There is not current user session available. Please make sure the user has signed in before attempting this action."),h(t.message,"No message found -- a message is required when requesting a message signature."),this.setIsRequestPending("status/StructuredMessageSigning");let a;return await handleSignStructuredDataRequest({appDetails:s,privateKey:r.appPrivateKey,stxAddress:i,network:o,domain:{name:((d=t.domain)==null?void 0:d.name)??s.name,version:((u=t.domain)==null?void 0:u.version)??"1.0.0",chainId:((S=t.domain)==null?void 0:S.chainId)??o.chainId},message:t.message,onFinish:l=>{var c;a=l,(c=t==null?void 0:t.onFinish)==null||c.call(t,l),this.setIsIdle("status/StructuredMessageSigning");},onCancel:l=>{var c;(c=t==null?void 0:t.onCancel)==null||c.call(t,l),this.setIsIdle("status/StructuredMessageSigning");}}),a};setNetwork=t=>{typeof t=="string"?this.setState(e=>({...e,network:t==="mainnet"?new StacksMainnet:new StacksTestnet})):this.setState(e=>({...e,network:t})),this.persist();};selectGaiaHubConfig(t){let e=this.selectHasSession(t),s=this.selectAccount(t);if(!(!e||!(s!=null&&s.appPrivateKey)))return generateGaiaHubConfigSync({gaiaHubUrl:"https://hub.blockstack.org",privateKey:s.appPrivateKey})}putFile=(t,e,{encrypt:s=!0,sign:i})=>{let r=this.selectHasSession(this.getState()),o=this.selectGaiaHubConfig(this.getState()),a=this.selectAccount(this.getState());if(!r){console.warn("There is not current user session available. Please make sure the user has signed in before attempting this action.");return}if(!(a!=null&&a.appPrivateKey)||!o){console.warn("The current user session has no `appPrivateKey` defined. Certain actions require an `appPrivateKey`, such as using gaia or encryption.");return}return putFile(t,e,{privateKey:a.appPrivateKey,gaiaHubConfig:o,encrypt:s,sign:i,wasString:typeof e=="string"})};getFile=(t,{decrypt:e=!0,verify:s})=>{let i=this.selectHasSession(this.getState()),r=this.selectGaiaHubConfig(this.getState()),o=this.selectAccount(this.getState());if(!i){console.warn("There is not current user session available. Please make sure the user has signed in before attempting this action.");return}if(!(o!=null&&o.appPrivateKey)||!r){console.warn("The current user session has no `appPrivateKey` defined. Certain actions require an `appPrivateKey`, such as using gaia or encryption.");return}return getFile(t,{privateKey:o.appPrivateKey,gaiaHubConfig:r,decrypt:e,verify:s})};async fetchBNSName(){var i;let t=this.selectStxAddress(this.getState()),e=this.selectNetwork(this.getState());if(!t){console.warn("No Stacks address found while trying to fetch BNS name");return}let s=e.getCoreApiUrl()+`/v1/addresses/stacks/${t}`;try{let o=await(await this.fetcher(s)).json();return (i=o==null?void 0:o.names)==null?void 0:i[0]}catch(r){console.log("[@micro-stacks/client] fetchBNSName failed",r);}}async fetchZoneFile(){try{let t=this.selectStxAddress(this.getState()),e=this.selectNetwork(this.getState());if(!t){console.warn("No Stacks address found while trying to fetch zonefile name");return}let s=e.getCoreApiUrl()+`/v1/names/${t}/zonefile`;return await(await this.fetcher(s)).json()}catch(t){console.log("[@micro-stacks/client] fetchZoneFile failed",t);}}async fetchProfile(){let t=this.selectAccount(this.getState());if(!!(t!=null&&t.profile_url))try{return await(await this.fetcher(t.profile_url)).json()}catch(e){console.log("[@micro-stacks/client] fetchProfile failed",e);}}encrypt(t,e={}){var s;if((e==null?void 0:e.publicKey)&&(e==null?void 0:e.privateKey))throw Error("Error: do not pass both `publicKey` and `privateKey` to client.encrypt");return encryptContent(t,{...e,privateKey:e.privateKey??((s=this.selectAccount(this.getState()))==null?void 0:s.appPrivateKey)})}decrypt(t,e){var i;let s=e.privateKey??((i=this.selectAccount(this.getState()))==null?void 0:i.appPrivateKey);if(!s)throw Error("You must pass a `privateKey` value to client.decrypt");return decryptContent(t,{privateKey:s})}};var _;function Y(n){let t=(n==null?void 0:n.client)??new N(n==null?void 0:n.config);return C?t:(_=t,_)}function p(n){return C?Y(n):_??Y(n)}var Fe=({client:n,state:t})=>n.selectAccounts(t||n.getState()),Be=({client:n,state:t})=>n.selectAccount(t||n.getState()),Le=({client:n,state:t})=>n.selectStxAddress(t||n.getState()),ze=({client:n,state:t})=>n.selectIdentityAddress(t||n.getState()),qe=({client:n,state:t})=>n.selectDecentralizedID(t||n.getState()),He=({client:n,state:t})=>n.selectNetwork(t||n.getState()),We=({client:n,state:t})=>n.selectStatuses(t||n.getState()),Ge=({client:n,state:t})=>n.selectAppDetails(t||n.getState()),je=(n,t=p())=>t.subscribe(t.selectAccounts,n,{equalityFn:I}),Je=(n,t=p())=>t.subscribe(t.selectAccount,n,{equalityFn:I}),Ze=(n,t=p())=>t.subscribe(t.selectStxAddress,n,{equalityFn:I}),Xe=(n,t=p())=>t.subscribe(t.selectIdentityAddress,n,{equalityFn:I}),Ye=(n,t=p())=>t.subscribe(t.selectDecentralizedID,n,{equalityFn:I}),Qe=(n,t=p())=>t.subscribe(t.selectNetwork,n,{equalityFn:I}),ts=(n,t=p())=>t.subscribe(t.selectStatuses,n,{equalityFn:I}),es=(n,t=p())=>t.subscribe(t.selectAppDetails,n,{equalityFn:I});

export { Q as DEFAULT_PREFIX, C as IS_SSR, N as MicroStacksClient, P as STORE_KEY, B as Status, F as StatusKeys, U as TxType, Tt as cleanDehydratedState, _ as client, Y as createClient, tt as createStorage, V as defaultStorage, Fe as getAccounts, Ge as getAppDetails, p as getClient, Be as getCurrentAccount, qe as getDecentralizedID, ze as getIdentityAddress, He as getNetwork, We as getStatus, Le as getStxAddress, M as noopStorage, je as watchAccounts, es as watchAppDetails, Je as watchCurrentAccount, Ye as watchDecentralizedID, Xe as watchIdentityAddress, Qe as watchNetwork, ts as watchStatus, Ze as watchStxAddress };
