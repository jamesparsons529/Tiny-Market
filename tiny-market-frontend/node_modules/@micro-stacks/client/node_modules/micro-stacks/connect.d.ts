import { StacksTransaction, PostConditionMode, PostCondition } from 'micro-stacks/transactions';
import { StacksNetwork, ChainID } from 'micro-stacks/network';
import { ClarityValue, ClarityAbi } from 'micro-stacks/clarity';
import { GaiaHubConfig } from 'micro-stacks/storage';
import { Signature } from '@noble/secp256k1';

declare const IS_BROWSER: boolean;
declare enum PersistedDataKeys {
    SessionStorageKey = "stacks-session",
    NetworkStorageKey = "stacks-network"
}

interface FinishedTxData {
    stacksTransaction: StacksTransaction;
    txRaw: string;
    txId: string;
}
declare const openTransactionPopup: (options: {
    token: string;
    onFinish?: ((payload: FinishedTxData) => void) | undefined;
    onCancel?: ((errorMessage?: string | undefined) => void) | undefined;
}) => Promise<void>;
interface SignatureData {
    signature: string;
    publicKey: string;
}
declare const openSignMessagePopup: (options: {
    token: string;
    onFinish?: ((payload: SignatureData) => void) | undefined;
    onCancel?: ((errorMessage?: string | undefined) => void) | undefined;
}) => Promise<void>;
declare const openSignStructuredDataPopup: (options: {
    token: string;
    onFinish?: ((payload: SignatureData) => void) | undefined;
    onCancel?: ((errorMessage?: string | undefined) => void) | undefined;
}) => Promise<void>;

interface StacksProvider {
    transactionRequest(payload: string): Promise<FinishedTxData>;
    profileUpdateRequest(payload: string): Promise<string>;
    authenticationRequest(payload: string): Promise<string>;
    signatureRequest(payload: string): Promise<SignatureData>;
    structuredDataSignatureRequest(payload: string): Promise<SignatureData>;
    getProductInfo: undefined | (() => {
        version: string;
        name: string;
        meta?: {
            tag?: string;
            commit?: string;
            [key: string]: any;
        };
        [key: string]: any;
    });
}

declare type Unsubscribe = () => void;
interface StorageAdapter<Value> {
    setItem(key: string, value: Value): void;
    getItem(key: string): Value | null | undefined;
    removeItem(key: string): void;
    subscribe?: (key: string, callback: (value: Value) => void) => Unsubscribe;
}
interface AsyncStorageAdapter<Value> {
    setItem(key: string, value: Value): Promise<void>;
    getItem(key: string): Promise<Value | null | undefined>;
    removeItem(key: string): Promise<void>;
    subscribe?: (key: string, callback: (value: Value) => void) => Unsubscribe;
}
declare const defaultStorageAdapter: StorageAdapter<string>;
declare const safeGetPublicKey: (privateKey?: string) => string | null;

declare enum TransactionTypes {
    ContractCall = "contract_call",
    ContractDeploy = "smart_contract",
    STXTransfer = "token_transfer"
}
interface TransactionOptionsBase {
    privateKey?: string;
    appDetails?: {
        name: string;
        icon: string;
    };
    postConditionMode?: PostConditionMode;
    postConditions?: (string | PostCondition)[];
    network?: StacksNetwork;
    stxAddress?: string;
    sponsored?: boolean;
    attachment?: string;
}
interface TransactionPayloadBase {
    appDetails?: {
        name: string;
        icon: string;
    };
    stxAddress?: string;
    network?: StacksNetwork;
    publicKey?: string | null;
    postConditionMode?: PostConditionMode;
    postConditions?: (string | PostCondition)[];
    onFinish?: (data: any) => void;
    onCancel?: (error: any) => void;
}
interface ContractDeployTxOptions extends TransactionOptionsBase {
    contractName: string;
    codeBody: string;
}
interface ContractDeployTxPayload extends TransactionPayloadBase {
    contractName: string;
    codeBody: string;
    txType: TransactionTypes.ContractDeploy;
}
interface ContractCallTxOptions extends TransactionOptionsBase {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: string[] | ClarityValue[];
    validateWithAbi?: boolean | ClarityAbi;
}
interface ContractCallTxPayload extends TransactionPayloadBase {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: (string | ClarityValue)[];
    txType: TransactionTypes.ContractCall;
}
interface StxTransferTxOptions extends TransactionOptionsBase {
    recipient: string;
    amount: bigint | string;
    memo?: string;
    onFinish?: (data: any) => void;
}
interface StxTransferTxPayload extends TransactionPayloadBase {
    recipient: string;
    amount: string;
    memo?: string;
    txType: TransactionTypes.STXTransfer;
}

declare function makeContractCallToken({ functionArgs, privateKey, ...options }: ContractCallTxOptions): Promise<string>;

declare function makeContractDeployToken({ privateKey, ...options }: ContractDeployTxOptions): Promise<string>;

declare function makeStxTransferToken({ privateKey, ...options }: StxTransferTxOptions): Promise<string>;

interface AuthResponsePayload {
    private_key?: string;
    username: string | null;
    hubUrl: string;
    associationToken: string;
    blockstackAPIUrl: string | null;
    core_token: string | null;
    email: string | null;
    exp: number;
    iat: number;
    iss: string;
    jti: string;
    version: string;
    profile: Profile;
    profile_url: string;
    public_keys: string[];
}
interface AuthRequestPayload {
    scopes: AuthScope[];
    redirect_uri: string;
    public_keys: string[];
    domain_name: string;
    appDetails: AppDetails;
}
interface Profile {
    '@context'?: 'http://schema.org';
    '@type'?: 'Person';
    account?: {
        '@type': 'Account';
        identifier: string;
        placeholder: boolean;
        proofType: 'http';
        proofUrl: string;
        service: string;
    }[];
    api?: {
        gaiaHubConfig?: Partial<GaiaHubConfig>;
        gaiaHubUrl?: string;
    };
    apps?: Record<string, string>;
    appsMeta?: Record<string, {
        storage: string;
        publicKey: string;
    }>;
    description?: string;
    image?: {
        '@type': 'ImageObject';
        contentUrl: string;
        name: 'avatar';
    }[];
    name?: string;
    stxAddress: {
        testnet: string;
        mainnet: string;
    };
}
interface StacksSessionState {
    addresses: {
        testnet: string;
        mainnet: string;
    };
    appPrivateKey?: string;
    associationToken?: string;
    hubUrl: string;
    public_keys?: string[];
    profile: Profile;
    profile_url: string;
    username: string | null;
    version?: string;
    decentralizedID?: string;
    identityAddress?: string;
}
declare type AuthScope = 'store_write' | 'publish_data';
interface AppDetails {
    name: string;
    icon: string;
}
interface AuthOptions {
    onFinish?: (payload: StacksSessionState) => void;
    onCancel?: (error?: Error) => void;
    onSignOut?: () => void;
    scopes?: AuthScope[];
    appDetails: AppDetails;
}

declare function authenticate(authOptions: AuthOptions, storageAdapter?: StorageAdapter<string>, serialize?: {
    (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
    (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
}): Promise<StacksSessionState | undefined>;
declare function generateAuthRequestPayload(authOptions: AuthOptions, transitPublicKey: string): AuthRequestPayload;
declare function signAuthRequest(payload: unknown, transitPrivateKey: string): Promise<string>;
declare function generateSignedAuthRequest(authOptions: AuthOptions, transitPrivateKey: string): Promise<string>;
declare function handleAuthResponse(authOptions: AuthOptions, transitPrivateKey: string): Promise<string>;
declare global {
    interface Window {
        StacksProvider?: StacksProvider;
    }
}

declare function getDIDType(decentralizedID: string): string;
declare function getAddressFromDID(decentralizedID: string): string | undefined;
declare function decodeAuthResponse(authResponseToken: string, transitPrivateKey: string): Promise<StacksSessionState>;

declare function genericTransactionPopupFactory<OnFinishedPayload, ErrorMessagePayload = string>(method: keyof StacksProvider): (options: {
    token: string;
    onFinish?: ((payload: OnFinishedPayload) => void) | undefined;
    onCancel?: ((errorMessage?: ErrorMessagePayload) => void) | undefined;
}) => Promise<void>;

declare enum WALLET_INSTALL_URLS {
    Chrome = "https://chrome.google.com/webstore/detail/hiro-wallet/ldinpeekobnhjjdofggfgjlcehhmanlj",
    Firefox = "https://addons.mozilla.org/en-US/firefox/addon/hiro-wallet/",
    Mobile = "https://www.xverse.app",
    Browser = "https://www.hiro.so/wallet/install-web"
}
declare type Browsers = 'Chrome' | 'Firefox' | 'Mobile' | 'Browser';
declare function getIsMobileDevice(): boolean | undefined;
declare function getBrowser(): Browsers | null;
declare function getWalletInstallUrl(browser: Browsers | null): WALLET_INSTALL_URLS;

interface SignatureRequestOptions {
    message: string;
    appDetails: {
        name: string;
        icon: string;
    };
    authOrigin?: string;
    stxAddress: string;
    privateKey?: string;
    network?: StacksNetwork;
}
declare type StructuredSignatureRequestOptions = Omit<SignatureRequestOptions, 'message'> & {
    message: string | ClarityValue;
    domain: {
        name: string;
        version: string;
        chainId?: ChainID;
    };
};
declare type SignedOptionsWithOnHandlers<T> = T & {
    onFinish?: (payload: SignatureData) => void;
    onCancel?: (errorMessage?: string) => void;
};

declare const generateSignMessagePayload: (options: SignatureRequestOptions) => Promise<string>;
declare const handleSignMessageRequest: (options: SignedOptionsWithOnHandlers<SignatureRequestOptions>) => Promise<void>;

declare const generateSignStructuredDataPayload: (options: StructuredSignatureRequestOptions) => Promise<string>;
declare const handleSignStructuredDataRequest: (options: SignedOptionsWithOnHandlers<StructuredSignatureRequestOptions>) => Promise<void>;

declare function hashMessage(message: string | Uint8Array): Uint8Array;
declare function encodeMessage(message: string | Uint8Array): Uint8Array;
declare function decodeMessage(encodedMessage: Uint8Array): Uint8Array;

declare const getPublicKeyFromSignature: ({ hash, signature, recoveryBytes, }: {
    hash: Uint8Array;
    signature: Signature;
    recoveryBytes: number | BigInt;
}) => Uint8Array;
declare const recoverSignature: (options: {
    signature: string;
    mode?: 'vrs' | 'rsv';
}) => {
    signature: Signature;
    recoveryBytes: bigint;
};
declare const verifyMessageSignature: (options: {
    message: string | Uint8Array;
    signature: string;
    publicKey?: string;
    stxAddress?: string;
    mode?: 'vrs' | 'rsv';
}) => boolean;

export { AsyncStorageAdapter, AuthOptions, AuthRequestPayload, AuthResponsePayload, AuthScope, Browsers, ContractCallTxOptions, ContractCallTxPayload, ContractDeployTxOptions, ContractDeployTxPayload, FinishedTxData, IS_BROWSER, PersistedDataKeys, Profile, SignatureData, SignatureRequestOptions, SignedOptionsWithOnHandlers, StacksProvider, StacksSessionState, StorageAdapter, StructuredSignatureRequestOptions, StxTransferTxOptions, StxTransferTxPayload, TransactionOptionsBase, TransactionPayloadBase, TransactionTypes, WALLET_INSTALL_URLS, authenticate, decodeAuthResponse, decodeMessage, defaultStorageAdapter, encodeMessage, generateAuthRequestPayload, generateSignMessagePayload, generateSignStructuredDataPayload, generateSignedAuthRequest, genericTransactionPopupFactory, getAddressFromDID, getBrowser, getDIDType, getIsMobileDevice, getPublicKeyFromSignature, getWalletInstallUrl, handleAuthResponse, handleSignMessageRequest, handleSignStructuredDataRequest, hashMessage, makeContractCallToken, makeContractDeployToken, makeStxTransferToken, openSignMessagePopup, openSignStructuredDataPopup, openTransactionPopup, recoverSignature, safeGetPublicKey, signAuthRequest, verifyMessageSignature };
