"use strict";'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var common = require('micro-stacks/common');

var a=(e=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(e,{get:(r,t)=>(typeof require!="undefined"?require:r)[t]}):e)(function(e){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var y=class{constructor(r){this.webCrypto=r;}async encrypt(r,t,i,n){let o,p;if(r==="aes-128-cbc")o="AES-CBC",p=128;else if(r==="aes-256-cbc")o="AES-CBC",p=256;else throw new Error(`Unsupported cipher algorithm "${r}"`);let C=await this.webCrypto.subtle.importKey("raw",t,{name:o,length:p},!1,["encrypt"]),l=await this.webCrypto.subtle.encrypt({name:o,iv:i},C,n);return new Uint8Array(l)}async decrypt(r,t,i,n){let o,p;if(r==="aes-128-cbc")o="AES-CBC",p=128;else if(r==="aes-256-cbc")o="AES-CBC",p=256;else throw new Error(`Unsupported cipher algorithm "${r}"`);let C=await this.webCrypto.subtle.importKey("raw",t,{name:o,length:p},!1,["decrypt"]),l=await this.webCrypto.subtle.decrypt({name:o,iv:i},C,n);return new Uint8Array(l)}};var s=class{constructor(r,t){this.createCipher=r,this.createDecipher=t;}async encrypt(r,t,i,n){if(r!=="aes-128-cbc"&&r!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${r}"`);let o=this.createCipher(r,t,i),p=common.concatByteArrays([o.update(n),o.final()]);return Promise.resolve(p)}async decrypt(r,t,i,n){if(r!=="aes-128-cbc"&&r!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${r}"`);let o=this.createDecipher(r,t,i),p=common.concatByteArrays([o.update(n),o.final()]);return Promise.resolve(p)}};function b(){return typeof crypto<"u"&&typeof crypto.subtle<"u"}function w(e){try{if(!a.resolve("crypto"))return !1;let t=a("crypto");return t?e?e(t):!0:!1}catch (e2){return !1}}var f='Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';async function u(){if(b())return {lib:crypto,name:"webCrypto"};try{return {lib:a("crypto"),name:"nodeCrypto"}}catch (e3){throw new Error(f)}}async function c(){let e=await u();return e.name==="webCrypto"?new y(e.lib):new s(e.lib.createCipheriv,e.lib.createDecipheriv)}async function g(e,r,t){return (await c()).encrypt("aes-256-cbc",r,e,t)}async function B(e,r,t){return (await c()).decrypt("aes-256-cbc",r,e,t)}async function L(e,r,t){return (await c()).encrypt("aes-128-cbc",r,e,t)}async function T(e,r,t){return (await c()).decrypt("aes-128-cbc",r,e,t)}

exports.NO_CRYPTO_LIB = f;
exports.aes128CbcDecrypt = T;
exports.aes128CbcEncrypt = L;
exports.aes256CbcDecrypt = B;
exports.aes256CbcEncrypt = g;
exports.getCryptoLib = u;
exports.isNodeCryptoAvailable = w;
exports.isSubtleCryptoAvailable = b;
