"use strict"; function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } }'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var c = require('react');
var D = require('use-sync-external-store/shim/with-selector.js');
var client = require('@micro-stacks/client');
var network = require('micro-stacks/network');
var reactAsyncHook = require('react-async-hook');
var common = require('micro-stacks/common');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return Object.freeze(n);
}

var c__namespace = /*#__PURE__*/_interopNamespace(c);
var D__default = /*#__PURE__*/_interopDefaultLegacy(D);

var p=c.createContext(null);var{useSyncExternalStoreWithSelector:v}=D__default["default"];function C(e){return ()=>{let t=u();return v(t.subscribe,t.getState,t.getState,n=>e({client:t,state:n}))}}var u=()=>{let e=c.useContext(p);if(!e)throw new Error("No MicroStacksClient set, wrap your app in MicroStacksClientProvider to set one");return e},N=C(e=>e.client.selectAppDetails(_nullishCoalesce(e.state, () => (e.client.getState())))),Ge=()=>{let e=N();return {appName:e==null?void 0:e.name,appIconUrl:e==null?void 0:e.icon}};var Be=C(client.getAccounts),K=C(client.getCurrentAccount),z=C(client.getIdentityAddress),G=C(client.getDecentralizedID),V=C(client.getStxAddress);function M(){let e=K(),t=V(),n=z(),f=G();return {appPrivateKey:_nullishCoalesce((e==null?void 0:e.appPrivateKey), () => (null)),rawAddress:e==null?void 0:e.address,identityAddress:n,decentralizedID:f,stxAddress:t,profileUrl:e==null?void 0:e.profile_url}}function Je(){return !!M().appPrivateKey}var g=C(client.getStatus);var nt=()=>{let e=u(),{stxAddress:t}=M(),n=g();return {openAuthRequest:e.authenticate,signOut:e.signOut,isSignedIn:!!t,isRequestPending:n[client.StatusKeys.Authentication]===client.Status.IsLoading}};var Z=C(client.getNetwork);function St(){let e=u(),t=Z();t.isMainnet=c.useCallback(()=>t.chainId===network.ChainID.Mainnet,[t.chainId]);let n=c.useMemo(()=>t.isMainnet(),[t]);return {setNetwork:e.setNetwork,network:t,isMainnet:n}}var Ot=e=>{let t=u(),n=g(),f=c.useCallback(async r=>t.signMessage({message:r.message,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=c.useMemo(()=>n[client.StatusKeys.MessageSigning]===client.Status.IsLoading,[n]);return {openSignMessage:f,isRequestPending:S}};var Tt=e=>{let t=u(),n=g(),f=c.useCallback(r=>t.signStructuredMessage({message:r.message,domain:r.domain,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=c.useMemo(()=>n[client.StatusKeys.StructuredMessageSigning]===client.Status.IsLoading,[n]);return {openSignStructuredMessage:f,isRequestPending:S}};var vt=e=>{let t=u(),n=g(),f=c.useCallback(r=>t.signTransaction(client.TxType.ContractDeploy,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=c.useMemo(()=>n[client.StatusKeys.TransactionSigning]===client.Status.IsLoading,[n]);return {openContractDeploy:f,isRequestPending:S}};var Ht=e=>{let t=u(),n=g(),f=c.useCallback(r=>t.signTransaction(client.TxType.ContractCall,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=c.useMemo(()=>n[client.StatusKeys.TransactionSigning]===client.Status.IsLoading,[n]);return {openContractCall:f,isRequestPending:S}};var Bt=e=>{let t=u(),n=g(),f=c.useCallback(r=>t.signTransaction(client.TxType.TokenTransfer,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=c.useMemo(()=>n[client.StatusKeys.TransactionSigning]===client.Status.IsLoading,[n]);return {openStxTokenTransfer:f,isRequestPending:S}};var Zt=(e,t)=>{let n=u(),f=c.useCallback(async()=>{let o=await n.getFile(e,{decrypt:t==null?void 0:t.decrypt,verify:t==null?void 0:t.verify});return o?t!=null&&t.deserialize?t.deserialize(o):o:null},[e,n,t]),{result:S,loading:r,error:i}=reactAsyncHook.useAsync(f,[t]);return {data:S,isLoading:r,hasError:!!i,error:i}},$t=(e,t,n)=>{let f=u(),S=n==null?void 0:n.serialize,r=c.useCallback(d=>S?S(d):JSON.stringify(d),[S]),i=c.useCallback(async()=>await _asyncNullishCoalesce(await f.putFile(e,r(t),{encrypt:n==null?void 0:n.encrypt,sign:n==null?void 0:n.sign}), async () => (null)),[e,t,f,r,n==null?void 0:n.encrypt,n==null?void 0:n.sign]),{loading:o,result:s,error:x,execute:y}=reactAsyncHook.useAsyncCallback(i,{onSuccess:c.useCallback(d=>{var m;return (m=n==null?void 0:n.onSuccess)==null?void 0:m.call(n,d)},[n]),onError:c.useCallback(d=>{var m;return (m=n==null?void 0:n.onError)==null?void 0:m.call(n,d)},[n])});return {data:s,isLoading:o,hasError:!!x,error:x,putFile:c.useCallback(async()=>y(),[y])}};var Me=(e,t)=>Boolean(common.getGlobalObject("document"))?c__namespace.useLayoutEffect(e,t):void 0,P=e=>{let t=c__namespace.useRef(e);return Me(()=>{t.current=e;},[]),c__namespace.useCallback((...n)=>t.current(...n),[])};var Te=()=>u().setOnNoWalletFound,Fe=()=>u().setOnPersistState,Ae=()=>u().setOnAuthentication,Re=()=>u().setOnSignOut,F=e=>{let t=Ae(),n=P(e);c.useEffect(()=>{e&&t(n);},[e,t,n]);},A=e=>{let t=Re(),n=P(e);c.useEffect(()=>{e&&t(n);},[e,t,n]);},R=e=>{let t=Fe(),n=P(e);c.useEffect(()=>{e&&t(n);},[e,t,n]);},E=e=>{let t=Te(),n=P(e);c.useEffect(()=>{e&&t(n);},[e,t,n]);};var De=c__namespace.memo(({onPersistState:e,onAuthentication:t,onSignOut:n,onNoWalletFound:f})=>(F(t),A(n),R(e),E(f),null));function ve(e,t,n){let f=c__namespace.useRef(!1);c__namespace.useEffect(()=>{n&&(t==null?void 0:t.onPersistState)&&!f.current&&(f.current=!0,!t.dehydratedState&&e.selectHasSession(e.getState())&&e.persist());},[n,e,t==null?void 0:t.onPersistState,t==null?void 0:t.dehydratedState]);}function Ue(e,t=!1){c__namespace.useEffect(()=>e.tabSyncSubscription(t),[e,t]);}var Sn=c__namespace.memo(({children:e,client:t,enableSessionConsistencyEffect:n=!1,enableTabSync:f=!1,dehydratedState:S,appIconUrl:r,appName:i,network:o,storage:s=client.defaultStorage,onPersistState:x,onAuthentication:y,onNoWalletFound:d,onSignOut:m})=>{if(c__namespace.useContext(p))throw Error("[@micro-stacks/react] Nested ClientProviders detected, you should only have one instance of this component at the root of your app.");let T=c__namespace.useMemo(()=>({appName:i,appIconUrl:r,dehydratedState:S,network:o,storage:s,onPersistState:x,onAuthentication:y,onNoWalletFound:d,onSignOut:m}),[i,r,S,o,s,x,y,d,m]),[l]=c__namespace.useState(()=>client.createClient({config:T,client:t}));return ve(l,T,n),Ue(l,f),c__namespace.createElement(p.Provider,{value:l},c__namespace.createElement(c__namespace.Fragment,null,t?null:c__namespace.createElement(De,{onPersistState:x,onAuthentication:y,onSignOut:m}),e))});

exports.ClientProvider = Sn;
exports.useAccount = M;
exports.useAccountsRaw = Be;
exports.useAppDetails = Ge;
exports.useAuth = nt;
exports.useCurrentStxAddress = V;
exports.useGetFile = Zt;
exports.useIsGaiaAvailable = Je;
exports.useMicroStacksClient = u;
exports.useNetwork = St;
exports.useOpenContractCall = Ht;
exports.useOpenContractDeploy = vt;
exports.useOpenSignMessage = Ot;
exports.useOpenSignStructuredMessage = Tt;
exports.useOpenStxTokenTransfer = Bt;
exports.usePutFile = $t;
exports.useStatuses = g;
