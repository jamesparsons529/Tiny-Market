import * as c from 'react';
import { createContext, useContext, useCallback, useMemo, useEffect } from 'react';
import D from 'use-sync-external-store/shim/with-selector.js';
import { createClient, defaultStorage, getAccounts, getStxAddress, getStatus, StatusKeys, Status, TxType, getCurrentAccount, getIdentityAddress, getDecentralizedID, getNetwork } from '@micro-stacks/client';
import { ChainID } from 'micro-stacks/network';
import { useAsync, useAsyncCallback } from 'react-async-hook';
import { getGlobalObject } from 'micro-stacks/common';

var p=createContext(null);var{useSyncExternalStoreWithSelector:v}=D;function C(e){return ()=>{let t=u();return v(t.subscribe,t.getState,t.getState,n=>e({client:t,state:n}))}}var u=()=>{let e=useContext(p);if(!e)throw new Error("No MicroStacksClient set, wrap your app in MicroStacksClientProvider to set one");return e},N=C(e=>e.client.selectAppDetails(e.state??e.client.getState())),Ge=()=>{let e=N();return {appName:e==null?void 0:e.name,appIconUrl:e==null?void 0:e.icon}};var Be=C(getAccounts),K=C(getCurrentAccount),z=C(getIdentityAddress),G=C(getDecentralizedID),V=C(getStxAddress);function M(){let e=K(),t=V(),n=z(),f=G();return {appPrivateKey:(e==null?void 0:e.appPrivateKey)??null,rawAddress:e==null?void 0:e.address,identityAddress:n,decentralizedID:f,stxAddress:t,profileUrl:e==null?void 0:e.profile_url}}function Je(){return !!M().appPrivateKey}var g=C(getStatus);var nt=()=>{let e=u(),{stxAddress:t}=M(),n=g();return {openAuthRequest:e.authenticate,signOut:e.signOut,isSignedIn:!!t,isRequestPending:n[StatusKeys.Authentication]===Status.IsLoading}};var Z=C(getNetwork);function St(){let e=u(),t=Z();t.isMainnet=useCallback(()=>t.chainId===ChainID.Mainnet,[t.chainId]);let n=useMemo(()=>t.isMainnet(),[t]);return {setNetwork:e.setNetwork,network:t,isMainnet:n}}var Ot=e=>{let t=u(),n=g(),f=useCallback(async r=>t.signMessage({message:r.message,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.MessageSigning]===Status.IsLoading,[n]);return {openSignMessage:f,isRequestPending:S}};var Tt=e=>{let t=u(),n=g(),f=useCallback(r=>t.signStructuredMessage({message:r.message,domain:r.domain,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.StructuredMessageSigning]===Status.IsLoading,[n]);return {openSignStructuredMessage:f,isRequestPending:S}};var vt=e=>{let t=u(),n=g(),f=useCallback(r=>t.signTransaction(TxType.ContractDeploy,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.TransactionSigning]===Status.IsLoading,[n]);return {openContractDeploy:f,isRequestPending:S}};var Ht=e=>{let t=u(),n=g(),f=useCallback(r=>t.signTransaction(TxType.ContractCall,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.TransactionSigning]===Status.IsLoading,[n]);return {openContractCall:f,isRequestPending:S}};var Bt=e=>{let t=u(),n=g(),f=useCallback(r=>t.signTransaction(TxType.TokenTransfer,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.TransactionSigning]===Status.IsLoading,[n]);return {openStxTokenTransfer:f,isRequestPending:S}};var Zt=(e,t)=>{let n=u(),f=useCallback(async()=>{let o=await n.getFile(e,{decrypt:t==null?void 0:t.decrypt,verify:t==null?void 0:t.verify});return o?t!=null&&t.deserialize?t.deserialize(o):o:null},[e,n,t]),{result:S,loading:r,error:i}=useAsync(f,[t]);return {data:S,isLoading:r,hasError:!!i,error:i}},$t=(e,t,n)=>{let f=u(),S=n==null?void 0:n.serialize,r=useCallback(d=>S?S(d):JSON.stringify(d),[S]),i=useCallback(async()=>await f.putFile(e,r(t),{encrypt:n==null?void 0:n.encrypt,sign:n==null?void 0:n.sign})??null,[e,t,f,r,n==null?void 0:n.encrypt,n==null?void 0:n.sign]),{loading:o,result:s,error:x,execute:y}=useAsyncCallback(i,{onSuccess:useCallback(d=>{var m;return (m=n==null?void 0:n.onSuccess)==null?void 0:m.call(n,d)},[n]),onError:useCallback(d=>{var m;return (m=n==null?void 0:n.onError)==null?void 0:m.call(n,d)},[n])});return {data:s,isLoading:o,hasError:!!x,error:x,putFile:useCallback(async()=>y(),[y])}};var Me=(e,t)=>Boolean(getGlobalObject("document"))?c.useLayoutEffect(e,t):void 0,P=e=>{let t=c.useRef(e);return Me(()=>{t.current=e;},[]),c.useCallback((...n)=>t.current(...n),[])};var Te=()=>u().setOnNoWalletFound,Fe=()=>u().setOnPersistState,Ae=()=>u().setOnAuthentication,Re=()=>u().setOnSignOut,F=e=>{let t=Ae(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);},A=e=>{let t=Re(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);},R=e=>{let t=Fe(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);},E=e=>{let t=Te(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);};var De=c.memo(({onPersistState:e,onAuthentication:t,onSignOut:n,onNoWalletFound:f})=>(F(t),A(n),R(e),E(f),null));function ve(e,t,n){let f=c.useRef(!1);c.useEffect(()=>{n&&(t==null?void 0:t.onPersistState)&&!f.current&&(f.current=!0,!t.dehydratedState&&e.selectHasSession(e.getState())&&e.persist());},[n,e,t==null?void 0:t.onPersistState,t==null?void 0:t.dehydratedState]);}function Ue(e,t=!1){c.useEffect(()=>e.tabSyncSubscription(t),[e,t]);}var Sn=c.memo(({children:e,client:t,enableSessionConsistencyEffect:n=!1,enableTabSync:f=!1,dehydratedState:S,appIconUrl:r,appName:i,network:o,storage:s=defaultStorage,onPersistState:x,onAuthentication:y,onNoWalletFound:d,onSignOut:m})=>{if(c.useContext(p))throw Error("[@micro-stacks/react] Nested ClientProviders detected, you should only have one instance of this component at the root of your app.");let T=c.useMemo(()=>({appName:i,appIconUrl:r,dehydratedState:S,network:o,storage:s,onPersistState:x,onAuthentication:y,onNoWalletFound:d,onSignOut:m}),[i,r,S,o,s,x,y,d,m]),[l]=c.useState(()=>createClient({config:T,client:t}));return ve(l,T,n),Ue(l,f),c.createElement(p.Provider,{value:l},c.createElement(c.Fragment,null,t?null:c.createElement(De,{onPersistState:x,onAuthentication:y,onSignOut:m}),e))});

export { Sn as ClientProvider, M as useAccount, Be as useAccountsRaw, Ge as useAppDetails, nt as useAuth, V as useCurrentStxAddress, Zt as useGetFile, Je as useIsGaiaAvailable, u as useMicroStacksClient, St as useNetwork, Ht as useOpenContractCall, vt as useOpenContractDeploy, Ot as useOpenSignMessage, Tt as useOpenSignStructuredMessage, Bt as useOpenStxTokenTransfer, $t as usePutFile, g as useStatuses };
